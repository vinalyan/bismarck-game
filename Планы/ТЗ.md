# Техническое задание: Веб-версия игры "Погоня за Бисмарком" 

## 1. Общее описание

### 1.1. Цель проекта
Разработка многопользовательской веб-версии настольной игры "Погоня за Бисмарком" с полной реализацией всех игровых механик.

### 1.2. Основные характеристики
- **Архитектура**: Client-Server с разделением логики
- **Backend**: Go (Golang) 
- **Frontend**: Веб-интерфейс (HTML/CSS/JavaScript + React/Vue)
- **База данных**: PostgreSQL (динамические данные) + Redis (кэш/сессии)
- **Статические данные**: Конфигурационные файлы JSON
- **Коммуникация**: REST API + WebSocket для реального времени
- **Многопользовательский режим**: Поддержка множества параллельных игр

## 2. Функциональные требования

### 2.1. Система пользователей и аутентификации

```go
type User struct {
    ID           string    `json:"id"`
    Username     string    `json:"username"`
    PasswordHash string    `json:"-"`
    Email        string    `json:"email"`
    Role         UserRole  `json:"role"`
    Stats        UserStats `json:"stats"`
    CreatedAt    time.Time `json:"created_at"`
    LastLogin    time.Time `json:"last_login"`
}

type UserStats struct {
    GamesPlayed   int     `json:"games_played"`
    GamesWon      int     `json:"games_won"`
    WinRate       float64 `json:"win_rate"`
    FavoriteSide  string  `json:"favorite_side"`
    TotalVP       int     `json:"total_vp"`
    TimePlayed    int     `json:"time_played"` // в минутах
}
```

**Эндпоинты:**
- `POST /api/auth/register` - регистрация нового пользователя
- `POST /api/auth/login` - аутентификация пользователя  
- `POST /api/auth/logout` - выход из системы
- `GET /api/user/profile` - получение профиля пользователя
- `GET /api/user/stats` - статистика игрока
- `PUT /api/user/preferences` - обновление настроек
- `GET /api/user/achievements` - достижения игрока

### 2.2. Система игр и лобби

#### 2.2.1. Модели данных
```go
type Game struct {
    ID           string       `json:"id"`
    Name         string       `json:"name"`
    Player1ID    string       `json:"player1_id"`  // Немецкий игрок
    Player2ID    string       `json:"player2_id"`  // Союзник
    CurrentTurn  int          `json:"current_turn"`
    CurrentPhase GamePhase    `json:"current_phase"`
    GameState    *GameState   `json:"game_state"`
    Status       GameStatus   `json:"status"`
    Settings     GameSettings `json:"settings"`
    CreatedAt    time.Time    `json:"created_at"`
    UpdatedAt    time.Time    `json:"updated_at"`
    CompletedAt  *time.Time   `json:"completed_at,omitempty"`
    Winner       *string      `json:"winner,omitempty"`
    VictoryType  VictoryType  `json:"victory_type,omitempty"`
}

type GameSettings struct {
    UseOptionalUnits      bool           `json:"use_optional_units"`
    EnableCrewExhaustion  bool           `json:"enable_crew_exhaustion"`
    VictoryConditions     VictoryConfig  `json:"victory_conditions"`
    TimeLimitMinutes      int            `json:"time_limit_minutes"`
    PrivateLobby          bool           `json:"private_lobby"`
    Password              string         `json:"password,omitempty"`
    MaxTurnTime           int            `json:"max_turn_time"` // в минутах
}
```

#### 2.2.2. Управление играми
**Эндпоинты:**
- `GET /api/games` - список доступных игр с фильтрацией и пагинацией
- `POST /api/games` - создание новой игры
- `POST /api/games/{id}/join` - присоединение к игре
- `GET /api/games/{id}` - получение состояния игры
- `POST /api/games/{id}/surrender` - сдача в текущей игре
- `POST /api/games/{id}/pause` - приостановка игры
- `DELETE /api/games/{id}` - удаление игры (если не начата)
- `GET /api/games/{id}/replay` - получение реплея игры
- `POST /api/games/{id}/chat` - отправка сообщения в чат игры

### 2.3. Игровая логика - расширенная

#### 2.3.1. Полная последовательность фаз
```go
type GamePhase string

const (
    PhaseVisibility    GamePhase = "visibility"
    PhaseShadow        GamePhase = "shadow" 
    PhaseMovement      GamePhase = "movement"
    PhaseSearch        GamePhase = "search"
    PhaseAirAttack     GamePhase = "air_attack"
    PhaseNavalCombat   GamePhase = "naval_combat"
    PhaseChance        GamePhase = "chance"
    PhaseAdmin         GamePhase = "admin"
)

type PhaseManager struct {
    currentPhase GamePhase
    phaseHandlers map[GamePhase]PhaseHandler
    phaseHistory []PhaseRecord
}

type PhaseRecord struct {
    Phase     GamePhase  `json:"phase"`
    Turn      int        `json:"turn"`
    StartTime time.Time  `json:"start_time"`
    EndTime   time.Time  `json:"end_time"`
    Duration  int        `json:"duration"` // в секундах
}
```

#### 2.3.2. Расширенная система действий игроков
```go
type ActionType string

const (
    ActionMoveUnit         ActionType = "move_unit"
    ActionCreateTF         ActionType = "create_tf"
    ActionSplitTF          ActionType = "split_tf"
    ActionStartRepair      ActionType = "start_repair"
    ActionStartRefuel      ActionType = "start_refuel"
    ActionPatrol           ActionType = "patrol"
    ActionSearch           ActionType = "search"
    ActionAirAttack        ActionType = "air_attack"
    ActionNavalCombat      ActionType = "naval_combat"
    ActionEvasionManeuver  ActionType = "evasion_maneuver"
    ActionDiversionManeuver ActionType = "diversion_maneuver"
    ActionConvoyHunt       ActionType = "convoy_hunt"
    ActionDeclarePort      ActionType = "declare_port"
    ActionAbortCombat      ActionType = "abort_combat"
    ActionAssignTorpedo    ActionType = "assign_torpedo"
    ActionChangePosition   ActionType = "change_position"
)

type GameAction struct {
    ID          string          `json:"id"`
    GameID      string          `json:"game_id"`
    PlayerID    string          `json:"player_id"`
    ActionType  ActionType      `json:"action_type"`
    Data        interface{}     `json:"data"`
    Timestamp   time.Time       `json:"timestamp"`
    Phase       GamePhase       `json:"phase"`
    Turn        int             `json:"turn"`
    Sequence    int             `json:"sequence"`
    CanUndo     bool            `json:"can_undo"`
    Validated   bool            `json:"validated"`
    ServerTime  time.Time       `json:"server_time"`
    Checksum    string          `json:"checksum"` // для защиты от читерства
}
```

## 3. Взаимодействие игрока с игрой

### 3.1. Принципы интерфейса

**Контекстно-зависимый интерфейс:**
```typescript
interface UIState {
    currentPhase: GamePhase;
    selectedUnit: Unit | null;
    selectedHex: string | null;
    availableActions: Action[];
    highlightedHexes: Map%3Cstring, HighlightInfo%3E;
    activeTool: ToolMode;
    pendingAction: Action | null;
    undoStack: Action[];
    redoStack: Action[];
}

interface HighlightInfo {
    type: 'movement' | 'search' | 'attack' | 'patrol' | 'invalid';
    reason: string;
    cost?: number;
    factors?: number;
    required?: number;
    units?: Unit[];
}

enum ToolMode {
    SELECT = "select",
    MOVE = "move", 
    SEARCH = "search",
    ATTACK = "attack",
    PATROL = "patrol",
    FORM_TF = "form_tf",
    REPAIR = "repair",
    REFUEL = "refuel"
}
```

### 3.2. Расширенная система выбора юнитов

**Клиентская логика выбора:**
```typescript
class ClientRuleEngine {
    private gameRules: GameRules;
    private gameState: GameState;
    
    canUnitBeSelected(unit: Unit, phase: GamePhase, player: Player): { canSelect: boolean; reason?: string } {
        // Проверка фазы игры
        if (!this.isUnitActionAllowedInPhase(unit, phase)) {
            return { canSelect: false, reason: 'action_not_allowed_in_phase' };
        }
        
        // Проверка владения
        if (unit.owner !== player.id) {
            return { canSelect: false, reason: 'not_your_unit' };
        }
        
        // Проверка статусных маркеров
        if (unit.hasMarker('no_movement') && this.requiresMovement(phase)) {
            return { canSelect: false, reason: 'unit_cannot_move' };
        }
        
        if (unit.isRepairing && !this.canInterruptRepair(phase)) {
            return { canSelect: false, reason: 'unit_is_repairing' };
        }
        
        if (unit.isRefueling && !this.canInterruptRefuel(phase)) {
            return { canSelect: false, reason: 'unit_is_refueling' };
        }
        
        // Проверка специальных ограничений
        if (this.isUnitRestricted(unit, phase)) {
            return { canSelect: false, reason: 'unit_is_restricted' };
        }
        
        return { canSelect: true };
    }
    
    getAvailableActionsForUnit(unit: Unit, phase: GamePhase): AvailableAction[] {
        const actions: AvailableAction[] = [];
        
        switch (phase) {
            case 'movement':
                if (this.canMove(unit)) {
                    actions.push({
                        type: 'move',
                        label: 'Переместить',
                        icon: '➡️',
                        description: 'Переместить юнит в другой гекс'
                    });
                }
                
                if (this.canPatrol(unit)) {
                    actions.push({
                        type: 'patrol',
                        label: 'Патрулировать',
                        icon: '🔄', 
                        description: 'Установить патруль в текущем гексе (+3 к поиску)'
                    });
                }
                
                if (this.canRepair(unit)) {
                    actions.push({
                        type: 'repair',
                        label: 'Ремонт в море',
                        icon: '🔧',
                        description: 'Попытаться починить повреждения'
                    });
                }
                
                if (this.canRefuel(unit)) {
                    actions.push({
                        type: 'refuel',
                        label: 'Дозаправить',
                        icon: '⛽',
                        description: 'Дозаправиться в порту или от танкера'
                    });
                }
                
                if (this.canFormTF(unit)) {
                    actions.push({
                        type: 'form_tf',
                        label: 'Создать ОС',
                        icon: '👥',
                        description: 'Объединить юниты в оперативное соединение'
                    });
                }
                break;
                
            case 'search':
                if (this.canSearch(unit)) {
                    actions.push({
                        type: 'search',
                        label: 'Искать',
                        icon: '🔍',
                        description: 'Искать вражеские юниты в гексе'
                    });
                }
                break;
                
            case 'air_attack':
                if (this.canAirAttack(unit)) {
                    actions.push({
                        type: 'air_attack', 
                        label: 'Воздушная атака',
                        icon: '✈️',
                        description: 'Атаковать вражеские корабли с воздуха'
                    });
                }
                break;
                
            case 'naval_combat':
                if (this.canNavalCombat(unit)) {
                    actions.push({
                        type: 'naval_combat',
                        label: 'Морской бой',
                        icon: '💥',
                        description: 'Начать морской бой с вражескими юнитами'
                    });
                }
                break;
        }
        
        return actions;
    }
}
```

### 3.3. Расширенная система выбора гексов

**Подсветка доступных гексов:**
```typescript
class HexHighlightingSystem {
    private highlightedHexes: Map<string, HighlightInfo> = new Map();
    private pathPreview: string[] = [];
    
    highlightMovementHexes(unit: Unit): void {
        // Очистка предыдущей подсветки
        this.clearHighlights();
        
        // Расчет доступных гексов
        const movementRange = this.calculateMovementRange(unit);
        
        movementRange.availableHexes.forEach(hex => {
            const validation = this.validateHexForMovement(unit, hex);
            
            this.highlightedHexes.set(hex, {
                type: validation.valid ? 'movement' : 'invalid',
                reason: validation.reason || 'movement',
                cost: validation.cost,
                units: this.getUnitsInHex(hex)
            });
        });
        
        this.renderHighlights();
    }
    
    highlightSearchHexes(player: Player): void {
        this.clearHighlights();
        
        // Получение всех гексов, где есть факторы поиска
        const searchableHexes = this.getHexesWithSearchFactors(player);
        
        searchableHexes.forEach(hex => {
            const factors = this.calculateSearchFactors(hex, player);
            const required = this.gameState.weather.visibility;
            
            this.highlightedHexes.set(hex, {
                type: factors >= required ? 'search' : 'invalid',
                reason: 'search',
                factors: factors,
                required: required,
                units: this.getEnemyUnitsInHex(hex, player)
            });
        });
        
        this.renderHighlights();
    }
    
    highlightAttackHexes(unit: AirUnit): void {
        this.clearHighlights();
        
        const attackRange = this.calculateAirAttackRange(unit);
        const enemyHexes = this.getEnemyHexesInRange(attackRange);
        
        enemyHexes.forEach(hex => {
            const hasShadowed = this.hasShadowedEnemy(hex);
            
            if (hasShadowed) {
                this.highlightedHexes.set(hex, {
                    type: 'attack',
                    reason: 'air_attack',
                    units: this.getEnemyUnitsInHex(hex, unit.owner),
                    canAttack: this.canUnitAttackHex(unit, hex)
                });
            }
        });
        
        this.renderHighlights();
    }
    
    showPathPreview(startHex: string, targetHex: string): void {
        const path = this.findPath(startHex, targetHex);
        
        if (path && path.length > 1) {
            this.pathPreview = path;
            
            // Подсветка пути
            path.forEach((hex, index) => {
                const isStart = index === 0;
                const isEnd = index === path.length - 1;
                
                this.highlightedHexes.set(hex, {
                    type: isStart ? 'path_start' : isEnd ? 'path_end' : 'path',
                    reason: 'movement_path',
                    segment: index,
                    isLast: isEnd
                });
            });
            
            this.renderHighlights();
            
            // Показ информации о пути
            this.showPathInfo(path, this.selectedUnit);
        }
    }
}
```

### 3.4. Расширенное контекстное меню действий
```typescript
class ContextMenu {
    private position: { x: number, y: number } = { x: 0, y: 0 };
    private target: Unit | string | null = null;
    
    showForUnit(unit: Unit, position: { x: number, y: number }): void {
        this.target = unit;
        this.position = position;
        
        const actions = this.getAvailableActionsForUnit(unit);
        this.renderMenu(actions, position);
    }
    
    showForHex(hexId: string, position: { x: number, y: number }): void {
        this.target = hexId;
        this.position = position;
        
        const actions = this.getAvailableActionsForHex(hexId);
        this.renderMenu(actions, position);
    }
    
    private getAvailableActionsForUnit(unit: Unit): ContextAction[] {
        const actions: ContextAction[] = [];
        const phase = this.gameState.currentPhase;
        
        // Базовые информационные действия
        actions.push({ 
            id: 'unit_info', 
            label: 'Информация о юните', 
            icon: 'ℹ️',
            category: 'info'
        });
        
        // Действия в зависимости от фазы
        if (phase === 'movement') {
            if (this.canMove(unit)) {
                actions.push({
                    id: 'move',
                    label: 'Переместить',
                    icon: '➡️',
                    category: 'movement',
                    hotkey: 'M'
                });
            }
            
            if (this.canPatrol(unit)) {
                actions.push({
                    id: 'patrol', 
                    label: 'Патрулировать',
                    icon: '🔄',
                    category: 'movement',
                    hotkey: 'P'
                });
            }
            
            if (this.canRepair(unit)) {
                actions.push({
                    id: 'repair',
                    label: 'Ремонт в море', 
                    icon: '🔧',
                    category: 'maintenance',
                    hotkey: 'R'
                });
            }
            
            if (this.canRefuel(unit)) {
                actions.push({
                    id: 'refuel',
                    label: 'Дозаправить',
                    icon: '⛽',
                    category: 'maintenance', 
                    hotkey: 'F'
                });
            }
        }
        
        if (phase === 'search' && this.canSearch(unit)) {
            actions.push({
                id: 'search',
                label: 'Искать вражеские юниты',
                icon: '🔍',
                category: 'search',
                hotkey: 'S'
            });
        }
        
        // Действия с оперативными соединениями
        if (this.canFormTF(unit)) {
            actions.push({
                id: 'form_tf',
                label: 'Создать оперативное соединение',
                icon: '👥',
                category: 'organization',
                hotkey: 'T'
            });
        }
        
        if (this.canSplitTF(unit)) {
            actions.push({
                id: 'split_tf',
                label: 'Разделить оперативное соединение', 
                icon: '👤',
                category: 'organization',
                hotkey: 'Shift+T'
            });
        }
        
        // Действия для обнаруженных вражеских юнитов
        if (this.isEnemyUnit(unit) && this.hasVisibility(unit)) {
            actions.push({
                id: 'track_enemy',
                label: 'Отслеживать вражеский юнит',
                icon: '👁️',
                category: 'intel'
            });
        }
        
        return this.groupActionsByCategory(actions);
    }
    
    private executeAction(action: ContextAction): void {
        switch (action.id) {
            case 'move':
                this.startMovementMode();
                break;
            case 'patrol':
                this.startPatrol();
                break;
            case 'repair':
                this.startRepair();
                break;
            case 'refuel':
                this.startRefuel();
                break;
            case 'search':
                this.performSearch();
                break;
            case 'form_tf':
                this.showTaskForceModal();
                break;
            case 'unit_info':
                this.showUnitInfoModal();
                break;
        }
        
        this.hide();
    }
}
```

## 4. Расширенная архитектура взаимодействия клиент-сервер

### 4.1. Детальное разделение ответственности

**Клиент (Frontend):**
```typescript
class GameClient {
    // Статические знания о правилах
    private ruleEngine: ClientRuleEngine;
    
    // Текущее состояние игры (частичное)
    private gameState: PartialGameState;
    
    // UI состояние
    private uiState: UIState;
    
    // Сетевой слой
    private api: GameAPI;
    private websocket: WebSocketClient;
    
    // Основные обязанности клиента:
    async initialize(): Promise<void> {
        // 1. Загрузка статических данных
        await this.loadStaticData();
        
        // 2. Подключение к игре
        await this.connectToGame();
        
        // 3. Настройка UI
        this.setupUI();
        
        // 4. Запуск игрового цикла
        this.startGameLoop();
    }
    
    // Валидация действий на клиенте
    validateActionLocally(action: GameAction): ValidationResult {
        // Быстрая проверка очевидных ошибок
        return this.ruleEngine.validateAction(action, this.gameState);
    }
    
    // Обработка пользовательского ввода
    handleUserInput(event: UserInputEvent): void {
        switch (event.type) {
            case 'unit_click':
                this.handleUnitClick(event.unitId);
                break;
            case 'hex_click':
                this.handleHexClick(event.hexId);
                break;
            case 'action_click':
                this.handleActionClick(event.actionId);
                break;
            case 'key_press':
                this.handleKeyPress(event.key);
                break;
        }
    }
}
```

**Сервер (Backend):**
```go
type GameServer struct {
    // Полное состояние всех игр
    games map[string]*Game
    
    // Сервисы
    actionValidator *ActionValidator
    gameEngine      *GameEngine
    stateManager    *StateManager
    
    // Сетевой слой
    apiServer    *APIServer
    wsHub        *WebsocketHub
    
    // Основные обязанности сервера:
    func (gs *GameServer) HandleAction(action *GameAction) error {
        // 1. Полная валидация действия
        if err := gs.actionValidator.Validate(action); err != nil {
            return err
        }
        
        // 2. Применение действия к состоянию игры
        newState, err := gs.gameEngine.ApplyAction(action)
        if err != nil {
            return err
        }
        
        // 3. Сохранение состояния
        if err := gs.stateManager.SaveGameState(action.GameID, newState); err != nil {
            return err
        }
        
        // 4. Рассылка обновлений всем игрокам
        gs.wsHub.BroadcastGameUpdate(action.GameID, newState)
        
        // 5. Логирование действия
        gs.logAction(action)
        
        return nil
    }
    
    // Сложные расчеты
    func (gs *GameServer) CalculateMovementRange(unitID string, gameID string) (*MovementRange, error) {
        gameState := gs.getGameState(gameID)
        unit := gameState.GetUnit(unitID)
        
        // Расчет с учетом полного состояния игры
        return gs.movementService.CalculateRange(unit, gameState)
    }
}
```

### 4.2. Расширенный протокол взаимодействия

**Начало игры - полные данные:**
```typescript
interface InitialGameData {
    // Основное состояние
    gameState: GameState;
    
    // Статические данные
    gameRules: GameRules;
    mapConfig: MapConfig;
    unitDefinitions: Record<string, UnitDef>;
    damageTables: DamageTables;
    weatherTables: WeatherTables;
    combatTables: CombatTables;
    
    // Информация об игроках
    players: PlayerInfo[];
    currentPlayer: string;
    
    // Настройки игры
    settings: GameSettings;
    
    // Мета-информация
    gameId: string;
    turn: number;
    phase: GamePhase;
    startedAt: string;
    timeLimit?: number;
}
```

**Обновления состояния - дифференциальные:**
```typescript
interface GameStateUpdate {
    type: 'state_update';
    gameId: string;
    sequence: number;
    timestamp: number;
    
    // Изменения состояния
    changes: StateChange[];
    
    // Текущий контекст
    currentTurn: number;
    currentPhase: GamePhase;
    activePlayer: string;
    
    // Дополнительная информация
    phaseTimeRemaining?: number;
    turnTimeRemaining?: number;
}

type StateChange = 
    | UnitMovedChange
    | UnitDamagedChange  
    | MarkerAddedChange
    | MarkerRemovedChange
    | WeatherChangedChange
    | CombatStartedChange
    | CombatEndedChange
    | UnitSunkChange
    | TaskForceCreatedChange
    | TaskForceSplitChange;

interface UnitMovedChange {
    type: 'unit_moved';
    unitId: string;
    fromHex: string;
    toHex: string;
    path: string[];
    fuelCost: number;
    newFuel: number;
}
```

**Запросы информации от сервера:**
```typescript
class ServerQueryService {
    // Запрос диапазона движения
    async getMovementRange(unitId: string): Promise<MovementRangeResponse> {
        const response = await this.api.get(`/games/${this.gameId}/units/${unitId}/movement-range`);
        return response.data;
    }
    
    // Запрос доступных целей для атаки
    async getAttackTargets(unitId: string): Promise<AttackTargetsResponse> {
        const response = await this.api.get(`/games/${this.gameId}/units/${unitId}/attack-targets`);
        return response.data;
    }
    
    // Запрос факторов поиска в гексе
    async getSearchInfo(hexId: string): Promise<SearchInfoResponse> {
        const response = await this.api.get(`/games/${this.gameId}/hexes/${hexId}/search-info`);
        return response.data;
    }
    
    // Запрос информации о бое
    async getCombatInfo(combatId: string): Promise<CombatInfoResponse> {
        const response = await this.api.get(`/games/${this.gameId}/combats/${combatId}`);
        return response.data;
    }
    
    // Запрос возможных маршрутов
    async getPathOptions(fromHex: string, toHex: string): Promise<PathOptionsResponse> {
        const response = await this.api.get(
            `/games/${this.gameId}/path?from=${fromHex}&to=${toHex}`
        );
        return response.data;
    }
}
```

### 4.3. Полный цикл взаимодействия на примере движения

```typescript
// 1. Игрок выбирает юнит
async onUnitSelected(unitId: string): Promise<void> {
    // Клиентская проверка
    const unit = this.gameState.getUnit(unitId);
    const validation = this.ruleEngine.canUnitBeSelected(unit, this.gameState.currentPhase, this.currentPlayer);
    
    if (!validation.canSelect) {
        this.showError(validation.reason!);
        return;
    }
    
    // Выбор юнита
    this.selectUnit(unitId);
    
    // Запрос к серверу для точных данных
    await this.loadUnitActions(unitId);
}

// 2. Загрузка доступных действий
async loadUnitActions(unitId: string): Promise<void> {
    try {
        this.showLoading('Загрузка доступных действий...');
        
        // Параллельная загрузка разных типов информации
        const [movementRange, attackTargets, searchInfo] = await Promise.all([
            this.queries.getMovementRange(unitId),
            this.queries.getAttackTargets(unitId),
            this.queries.getSearchInfo(this.selectedHex)
        ]);
        
        // Обновление UI с полученными данными
        this.updateUIWithAvailableActions({
            movementRange,
            attackTargets, 
            searchInfo
        });
        
    } catch (error) {
        this.showError('Ошибка загрузки данных');
    } finally {
        this.hideLoading();
    }
}

// 3. Игрок выбирает действие - движение
onMoveActionSelected(): void {
    this.setToolMode(ToolMode.MOVE);
    
    // Подсветка доступных гексов на основе данных от сервера
    this.highlightMovementHexes(this.movementRange.availableHexes);
    
    // Показ информации о движении
    this.showMovementInfo(this.selectedUnit, this.movementRange);
}

// 4. Игрок выбирает целевой гекс
onHexSelectedForMovement(hexId: string): void {
    if (!this.isHexHighlighted(hexId)) return;
    
    // Расчет пути (может быть на клиенте или сервере)
    const path = this.findPath(this.selectedUnit.position, hexId);
    
    if (!path) {
        this.showError('Невозможно построить маршрут');
        return;
    }
    
    // Предпросмотр пути и стоимости
    this.showPathPreview(path);
    this.showMovementCost(this.calculateMovementCost(path));
    
    // Подтверждение действия
    this.showConfirmationDialog({
        title: 'Подтверждение движения',
        message: `Переместить ${this.selectedUnit.name} в гекс ${hexId}?`,
        onConfirm: () => this.executeMoveAction(path),
        onCancel: () => this.cancelMovement()
    });
}

// 5. Отправка действия на сервер
async executeMoveAction(path: string[]): Promise<void> {
    const action: MoveAction = {
        type: 'move_unit',
        unitId: this.selectedUnit.id,
        path: path,
        targetHex: path[path.length - 1],
        playerId: this.currentPlayer.id,
        timestamp: Date.now(),
        turn: this.gameState.turn,
        phase: this.gameState.currentPhase
    };
    
    try {
        // Клиентская пред-валидация
        const localValidation = this.validateActionLocally(action);
        if (!localValidation.valid) {
            this.showError(localValidation.reason!);
            return;
        }
        
        // Отправка на сервер
        const response = await this.api.sendAction(action);
        
        if (response.success) {
            // Действие успешно применено
            this.showSuccess('Юнит успешно перемещен');
            this.clearSelection();
        } else {
            // Сервер отклонил действие
            this.showError(response.error!);
        }
        
    } catch (error) {
        this.showError('Ошибка сети при отправке действия');
    }
}

// 6. Серверная обработка (бекенд)
func (gs *GameServer) handleMoveAction(action *MoveAction) (*ActionResult, error) {
    // Полная валидация на сервере
    validation := gs.actionValidator.ValidateMoveAction(action, gs.gameState)
    if !validation.Valid {
        return nil, errors.New(validation.Reason)
    }
    
    // Применение действия
    newState, err := gs.gameEngine.ApplyMoveAction(action, gs.gameState)
    if err != nil {
        return nil, err
    }
    
    // Рассылка обновлений
    update := gs.createStateUpdate(gs.gameState, newState, []StateChange{
        {
            Type: "unit_moved",
            UnitID: action.UnitID,
            FromHex: oldPosition,
            ToHex: action.TargetHex,
            Path: action.Path,
            FuelCost: calculatedCost,
        },
    })
    
    gs.wsHub.Broadcast(update)
    
    return &ActionResult{Success: true, Update: update}, nil
}
```

## 5. Расширенные критические игровые системы

### 5.1. Полная система юнитов

```go
type NavalUnit struct {
    ID           string          `json:"id"`
    Name         string          `json:"name"`
    Type         UnitType        `json:"type"`
    Class        string          `json:"class"`
    Owner        string          `json:"owner"`
    Nationality  string          `json:"nationality"`
    Position     string          `json:"position"`
    Evasion      int             `json:"evasion"`
    BaseEvasion  int             `json:"base_evasion"`
    SpeedRating  SpeedType       `json:"speed_rating"`
    Radar        RadarType       `json:"radar"`
    FuelPoints   int             `json:"fuel_points"`
    MaxFuel      int             `json:"max_fuel"`
    IsDamaged    bool            `json:"is_damaged"`
    
    // Тактические характеристики
    PrimaryArmamentBow   int `json:"primary_armament_bow"`
    PrimaryArmamentStern int `json:"primary_armament_stern"`
    SecondaryArmament    int `json:"secondary_armament"`
    Torpedoes           int `json:"torpedoes"`
    MaxTorpedoes        int `json:"max_torpedoes"`
    HullPoints          int `json:"hull_points"`
    MaxHullPoints       int `json:"max_hull_points"`
    
    // Статусные маркеры
    Markers      []UnitMarker    `json:"markers"`
    Damage       []Damage        `json:"damage"`
    EvasionEffects []EvasionEffect `json:"evasion_effects"`
    
    // История движений для расчета топлива
    MovementHistory []MovementRecord `json:"movement_history"`
    
    // Флаг принадлежности к TF
    TaskForceID  *string         `json:"task_force_id,omitempty"`
    
    // Временные модификаторы
    TemporaryModifiers []UnitModifier `json:"temporary_modifiers"`
}

type AirUnit struct {
    ID            string        `json:"id"`
    Name          string        `json:"name"`
    Type          AirUnitType   `json:"type"`
    Owner         string        `json:"owner"`
    Position      string        `json:"position"`
    BasePosition  string        `json:"base_position"`
    MaxSpeed      int           `json:"max_speed"`
    Endurance     int           `json:"endurance"`
    CurrentFuel   int           `json:"current_fuel"`
    SearchFactors int           `json:"search_factors"`
    
    // Статус
    Status        AirUnitStatus `json:"status"`
    RefitTurns    int           `json:"refit_turns"`
    
    // Способности
    Capabilities  AirCapabilities `json:"capabilities"`
    
    // Маркеры пути полета
    FlightPathMarkers []FlightPathMarker `json:"flight_path_markers"`
}

type TaskForce struct {
    ID          string   `json:"id"`
    Name        string   `json:"name"`
    Owner       string   `json:"owner"`
    Position    string   `json:"position"`
    Units       []string `json:"unit_ids"`
    Marker      string   `json:"marker"`
    SpeedRating SpeedType `json:"speed_rating"` // по самому медленному юниту
}
```

### 5.2. Расширенная система погоды и видимости

```go
type WeatherSystem struct {
    CurrentWeather  WeatherState     `json:"current_weather"`
    WeatherTrack    int              `json:"weather_track"` // 0-9
    History         []WeatherRecord  `json:"history"`
    Forecast        []WeatherPrediction `json:"forecast"`
}

type WeatherState struct {
    Level          int       `json:"level"` // 0-9
    IsFog          bool      `json:"is_fog"`
    Visibility     int       `json:"visibility"` // 1-9 или 10 (X)
    TimeOfDay      TimeOfDay `json:"time_of_day"`
    DayNumber      int       `json:"day_number"`
    TurnInDay      int       `json:"turn_in_day"`
    Date           string    `json:"date"` // "1941-05-24"
}

type TimeOfDay string
const (
    TimeMorning   TimeOfDay = "morning"
    TimeAfternoon TimeOfDay = "afternoon" 
    TimeNight     TimeOfDay = "night"
)

// Сервис погоды
type WeatherService struct {
    gameState *GameState
    changeTable []int // [-2, -1, 0, 0, 1, 1, 2, 2, 3, 3]
    
    func (ws *WeatherService) UpdateWeather() error {
        // Бросок на таблице изменения погоды
        roll := ws.rollWeatherChange()
        newTrack := ws.calculateNewTrack(roll)
        
        // Обновление состояния
        ws.updateWeatherState(newTrack)
        ws.calculateVisibility()
        
        // Проверка особых условий
        if ws.CurrentWeather.Level == 9 {
            ws.checkSpecialFuelExpenditure()
        }
        
        // Логирование изменения
        ws.recordWeatherChange()
        
        return nil
    }
    
    func (ws *WeatherService) calculateVisibility() int {
        weatherLevel := ws.CurrentWeather.Level
        timeModifier := ws.getTimeOfDayModifier()
        visibility := weatherLevel + timeModifier
        
        // Корректировка согласно правилам
        if visibility > 9 {
            return 10 // X - никакой видимости
        }
        
        // Учет тумана
        if ws.CurrentWeather.IsFog {
            visibility = 10 // X в тумане
        }
        
        return visibility
    }
    
    func (ws *WeatherService) getTimeOfDayModifier() int {
        switch ws.CurrentWeather.TimeOfDay {
        case TimeMorning, TimeAfternoon:
            return 0
        case TimeNight:
            return 3
        default:
            return 0
        }
    }
}
```

### 5.3. Расширенная система поиска и обнаружения

```go
type SearchSystem struct {
    SearchFactors  map[string]int          `json:"search_factors"` // hex -> factors
    SearchResults  map[string]SearchResult `json:"search_results"`
    DetectionHistory []DetectionRecord     `json:"detection_history"`
}

type SearchService struct {
    gameState *GameState
    searchTables SearchTables
}

func (ss *SearchService) PerformSearch(hexID string, playerID string) (*SearchResult, error) {
    // Расчет факторов поиска
    factors := ss.calculateSearchFactors(hexID, playerID)
    required := ss.gameState.Weather.Visibility
    
    if factors < required {
        return &SearchResult{
            Success: false, 
            Factors: factors,
            Required: required,
            Reason: "insufficient_search_factors"
        }, nil
    }
    
    // Обнаружение юнитов
    detectedUnits := ss.detectUnitsInHex(hexID, playerID)
    
    if len(detectedUnits) == 0 {
        return &SearchResult{
            Success: true,
            Factors: factors,
            DetectedUnits: []DetectedUnit{},
            MarkerType: "", // нет юнитов для маркировки
        }, nil
    }
    
    // Определение типа маркера (Sighted/Shadowed)
    markerType := ss.determineMarkerType(hexID, playerID)
    
    result := &SearchResult{
        Success:       true,
        Factors:       factors,
        DetectedUnits: detectedUnits,
        MarkerType:    markerType,
        HexID:         hexID,
        PlayerID:      playerID,
    }
    
    // Применение результатов поиска
    ss.applySearchResults(result)
    
    return result, nil
}

func (ss *SearchService) calculateSearchFactors(hexID string, playerID string) int {
    factors := 0
    
    // Базовые факторы гекса
    hex := ss.gameState.Map.GetHex(hexID)
    factors += hex.IntrinsicSearch
    
    // Юниты в гексе
    units := ss.gameState.GetUnitsInHex(hexID)
    for _, unit := range units {
        if unit.Owner == playerID && unit.CanContributeSearch() {
            factors += 1 // каждый свой юнит дает +1
        }
    }
    
    // Маркеры патруля
    if patrolMarkers := ss.gameState.GetMarkersInHex(hexID, "patrol"); len(patrolMarkers) > 0 {
        factors += 3 // каждый маркер патруля дает +3
    }
    
    // Маркеры пути полета
    if flightMarkers := ss.gameState.GetMarkersInHex(hexID, "flight_path_search"); len(flightMarkers) > 0 {
        factors += len(flightMarkers) * 2 // каждый маркер дает +2
    }
    
    return factors
}

func (ss *SearchService) detectUnitsInHex(hexID string, playerID string) []DetectedUnit {
    var detected []DetectedUnit
    units := ss.gameState.GetUnitsInHex(hexID)
    
    for _, unit := range units {
        // Не показываем свои юниты
        if unit.Owner == playerID {
            continue
        }
        
        // Определение уровня информации о юните
        detectionLevel := ss.determineDetectionLevel(unit, playerID)
        
        detectedUnit := DetectedUnit{
            UnitID:    unit.ID,
            UnitType:  unit.Type,
            IsInTF:    unit.TaskForceID != nil,
            ExactType: detectionLevel == "exact",
            Confidence: ss.calculateConfidence(unit, playerID),
        }
        
        // Для оперативных соединений - дополнительная информация
        if unit.TaskForceID != nil {
            tf := ss.gameState.GetTaskForce(*unit.TaskForceID)
            detectedUnit.TFSize = len(tf.Units)
            detectedUnit.TFComposition = ss.analyzeTFComposition(tf, playerID)
        }
        
        detected = append(detected, detectedUnit)
    }
    
    return detected
}
```


## 6. Расширенные критические игровые системы (продолжение)

### 6.1. Система оперативных соединений (Task Forces)

```go
type TaskForceSystem struct {
    TaskForces map[string]*TaskForce `json:"task_forces"`
    TFCounters map[string]int        `json:"tf_counters"` // для нумерации
}

type TaskForceService struct {
    gameState *GameState
}

func (tfs *TaskForceService) CreateTaskForce(unitIDs []string, position string, playerID string) (*TaskForce, error) {
    // Проверка, что все юниты в одном гексе
    if !tfs.areUnitsInSameHex(unitIDs, position) {
        return nil, errors.New("units must be in the same hex to form TF")
    }
    
    // Проверка, что юниты принадлежат игроку
    for _, unitID := range unitIDs {
        unit := tfs.gameState.GetUnit(unitID)
        if unit.Owner != playerID {
            return nil, errors.New("all units must belong to the player")
        }
        if unit.IsShadowed {
            return nil, errors.New("cannot form TF with shadowed units")
        }
    }
    
    // Создание TF
    tf := &TaskForce{
        ID:        tfs.generateTFID(),
        Name:      tfs.generateTFName(playerID),
        Owner:     playerID,
        Position:  position,
        Units:     unitIDs,
        CreatedAt: time.Now(),
    }
    
    // Расчет характеристик TF
    tfs.calculateTFProperties(tf)
    
    // Применение TF к состоянию игры
    tfs.applyTFToGameState(tf)
    
    return tf, nil
}

func (tfs *TaskForceService) calculateTFProperties(tf *TaskForce) {
    // Скорость TF определяется самым медленным кораблем
    minSpeed := SpeedFast
    for _, unitID := range tf.Units {
        unit := tfs.gameState.GetUnit(unitID)
        if unit.SpeedRating < minSpeed {
            minSpeed = unit.SpeedRating
        }
    }
    tf.SpeedRating = minSpeed
    
    // Эмблема TF
    tf.Marker = tfs.generateTFMarker(tf.Owner)
}

func (tfs *TaskForceService) SplitTaskForce(tfID string, unitsToRemove []string, playerID string) error {
    tf := tfs.gameState.GetTaskForce(tfID)
    if tf.Owner != playerID {
        return errors.New("not your task force")
    }
    
    // Проверка, что TF не shadowed
    if tf.IsShadowed {
        return errors.New("cannot split shadowed TF")
    }
    
    // Удаление юнитов из TF
    remainingUnits := []string{}
    for _, unitID := range tf.Units {
        if !contains(unitsToRemove, unitID) {
            remainingUnits = append(remainingUnits, unitID)
        }
    }
    
    if len(remainingUnits) < 2 {
        // Если осталось меньше 2 юнитов, расформировать TF
        tfs.disbandTaskForce(tfID)
    } else {
        // Обновить существующий TF
        tf.Units = remainingUnits
        tfs.calculateTFProperties(tf)
    }
    
    // Вернуть удаленные юниты в отдельное состояние
    for _, unitID := range unitsToRemove {
        unit := tfs.gameState.GetUnit(unitID)
        unit.TaskForceID = nil
        unit.Position = tf.Position // остаются в том же гексе
    }
    
    return nil
}
```

### 6.2. Система конвоев и охоты

```go
type ConvoySystem struct {
    ActiveConvoys   map[string]*ConvoyInstance `json:"active_convoys"`
    SpawnSchedule   map[int][]string           `json:"spawn_schedule"` // turn -> convoy IDs
    HuntedConvoys   map[string]bool            `json:"hunted_convoys"`
    ConvoyRoutes    map[string]ConvoyRoute     `json:"convoy_routes"`
}

type ConvoyService struct {
    gameState *GameState
    convoyConfig ConvoyConfig
}

func (cs *ConvoyService) SpawnConvoys(turn int) error {
    convoyIDs, exists := cs.SpawnSchedule[turn]
    if !exists {
        return nil // нет конвоев для этого хода
    }
    
    for _, convoyID := range convoyIDs {
        route := cs.ConvoyRoutes[convoyID]
        convoy := &ConvoyInstance{
            ID:          convoyID,
            RouteID:     route.ID,
            CurrentHex:  route.StartHex,
            Composition: route.DefaultComposition,
            Escorts:     route.Escorts,
            Value:       route.Value,
            Status:      "active",
            SpawnTurn:   turn,
        }
        
        cs.ActiveConvoys[convoyID] = convoy
        cs.placeConvoyOnMap(convoy)
    }
    
    return nil
}

func (cs *ConvoyService) HuntConvoys(huntingUnitID string, playerID string) (*ConvoyHuntResult, error) {
    huntingUnit := cs.gameState.GetUnit(huntingUnitID)
    
    // Проверка возможности охоты
    if !cs.canHuntConvoys(huntingUnit, playerID) {
        return nil, errors.New("unit cannot hunt convoys")
    }
    
    // Бросок на таблице охоты
    roll := cs.rollConvoyHunt()
    modifiedRoll := cs.applyHuntModifiers(roll, huntingUnit)
    
    result := &ConvoyHuntResult{
        Roll: roll,
        ModifiedRoll: modifiedRoll,
        HuntingUnit: huntingUnitID,
    }
    
    switch {
    case modifiedRoll == 0:
        // Возможный контакт с конвоем
        convoy := cs.findConvoyInRange(huntingUnit.Position)
        if convoy != nil {
            result.ConvoyContact = convoy
            result.ConvoyFound = true
        }
    case modifiedRoll == 1:
        // Одиночное торговое судно
        result.SingleMerchant = true
        result.VP = 0.5
    default:
        // Ничего не найдено
        result.NothingFound = true
    }
    
    // Применение результатов охоты
    cs.applyHuntResults(result, huntingUnit)
    
    return result, nil
}

func (cs *ConvoyService) canHuntConvoys(unit *NavalUnit, playerID string) bool {
    // Только немецкие BB, BC, CA могут охотиться на конвои
    if unit.Owner != "german" {
        return false
    }
    
    if unit.Type != "BB" && unit.Type != "BC" && unit.Type != "CA" {
        return false
    }
    
    // Нельзя охотиться если shadowed
    if unit.IsShadowed {
        return false
    }
    
    // Дополнительные ограничения из правил
    if unit.HasReducedEvasion && cs.isUnitHeadedToPort(unit) {
        return false
    }
    
    // Должен находиться на маршруте конвоя вне границ авиации
    return cs.isOnConvoyRoute(unit.Position) && cs.isOutsideAirBoundaries(unit.Position)
}
```

### 6.3. Система подводных лодок

```go
type SubmarineSystem struct {
    ContactSchedule map[int]bool              `json:"contact_schedule"` // turn -> имеет ли контакт
    SubmarineTypes  map[string]SubmarineType  `json:"submarine_types"`
}

type SubmarineService struct {
    gameState *GameState
}

func (ss *SubmarineService) CheckSubmarineContact(turn int) (*SubmarineContact, error) {
    // Проверка, есть ли контакт в этот ход
    hasContact, exists := ss.ContactSchedule[turn]
    if !exists || !hasContact {
        return nil, nil // нет контакта в этот ход
    }
    
    // Бросок на таблице контакта
    contactRoll := ss.rollSubmarineContact()
    if contactRoll > 2 { // 0-2 успех, 3-9 провал
        return nil, nil
    }
    
    // Бросок на таблице атаки
    attackRoll := ss.rollSubmarineAttack()
    
    contact := &SubmarineContact{
        Turn:       turn,
        ContactRoll: contactRoll,
        AttackRoll: attackRoll,
    }
    
    // Определение типа подлодки и целей
    switch {
    case attackRoll == 0:
        // Союзная подлодка атакует немецкие корабли
        contact.SubmarineType = "allied"
        contact.Target = ss.findGermanTarget()
    case attackRoll >= 1 && attackRoll <= 6:
        // Немецкая подлодка обнаруживает союзные корабли
        contact.SubmarineType = "german"
        contact.Target = ss.findAlliedTarget()
    case attackRoll >= 7 && attackRoll <= 9:
        // Немецкая подлодка атакует союзные корабли
        contact.SubmarineType = "german"
        contact.Target = ss.findAlliedTarget()
        contact.WillAttack = true
    }
    
    // Разрешение контакта
    ss.resolveSubmarineContact(contact)
    
    return contact, nil
}

func (ss *SubmarineService) resolveSubmarineContact(contact *SubmarineContact) {
    if contact.WillAttack {
        // Проведение торпедной атаки
        attackResult := ss.resolveTorpedoAttack(contact.Target, "submarine")
        contact.AttackResult = attackResult
        
        // Применение повреждений
        if attackResult.Hits > 0 {
            ss.applyDamage(contact.Target, attackResult.Damage)
        }
    }
    
    // Обновление информации о обнаружении
    ss.updateDetection(contact)
}
```

### 6.4. Система случайных событий (Random Spotting)

```go
type RandomSpottingSystem struct {
    SpottingTable RandomSpottingTable `json:"spotting_table"`
}

type SpottingService struct {
    gameState *GameState
}

func (ss *SpottingService) PerformRandomSpotting() []*SpottingResult {
    var results []*SpottingResult
    
    // Проверка для каждого немецкого юнита/TF
    germanUnits := ss.gameState.GetGermanUnits()
    
    for _, unit := range germanUnits {
        // Для TF - один бросок на все соединение
        if unit.TaskForceID != nil {
            tf := ss.gameState.GetTaskForce(*unit.TaskForceID)
            if ss.alreadyCheckedTF(tf.ID) {
                continue
            }
            result := ss.checkSpottingForTF(tf)
            results = append(results, result)
            continue
        }
        
        // Для одиночных юнитов
        result := ss.checkSpottingForUnit(unit)
        results = append(results, result)
    }
    
    return results
}

func (ss *SpottingService) checkSpottingForUnit(unit *NavalUnit) *SpottingResult {
    // Определение колонки в таблице по местоположению
    column := ss.determineSpottingColumn(unit.Position)
    
    // Бросок на обнаружение
    roll := ss.rollSpotting()
    spottingValue := ss.SpottingTable.GetValue(column, ss.gameState.Weather.Visibility)
    
    result := &SpottingResult{
        UnitID: unit.ID,
        Position: unit.Position,
        Roll: roll,
        SpottingValue: spottingValue,
        Column: column,
    }
    
    if roll == 0 {
        // Huff-Duff - только местоположение
        result.HuffDuff = true
        result.LocationRevealed = true
    } else if roll <= spottingValue {
        // Полное обнаружение
        result.FullyLocated = true
        result.LocationRevealed = true
        result.UnitInfoRevealed = true
    }
    
    return result
}
```

## 7. Расширенная система тактического боя

### 7.1. Тактическая карта и позиционирование

```go
type TacticalCombatSystem struct {
    ActiveCombats    map[string]*NavalCombat `json:"active_combats"`
    CombatSequence   []string                `json:"combat_sequence"`
    TacticalMaps     map[string]*TacticalMap `json:"tactical_maps"`
}

type TacticalMap struct {
    ID              string          `json:"id"`
    GameID          string          `json:"game_id"`
    HexID           string          `json:"hex_id"`
    SeaZones        []SeaZone       `json:"sea_zones"`
    MovementZones   []MovementZone  `json:"movement_zones"`
    Units           []TacticalUnit  `json:"units"`
    Visibility      int             `json:"visibility"`
    CurrentRound    int             `json:"current_round"`
    MaxRounds       int             `json:"max_rounds"`
    Weather         WeatherState    `json:"weather"`
}

type TacticalUnit struct {
    UnitID          string          `json:"unit_id"`
    Position        string          `json:"position"` // Movement Zone ID
    Facing          string          `json:"facing"`   // closing, opening, breaking-off
    CurrentSpeed    int             `json:"current_speed"`
    EvasionEffects  []int           `json:"evasion_effects"`
    DamageTaken     []Damage        `json:"damage_taken"`
    HasFired        bool            `json:"has_fired"`
    TargetAcquired  string          `json:"target_acquired,omitempty"`
    TorpedoesUsed   int             `json:"torpedoes_used"`
    MovementUsed    int             `json:"movement_used"`
}

type CombatManager struct {
    gameState *GameState
    combatServices map[CombatStep]CombatStepHandler
}

func (cm *CombatManager) StartNavalCombat(hexID string, participants []string) (*NavalCombat, error) {
    combat := &NavalCombat{
        ID:           generateCombatID(),
        HexID:        hexID,
        Participants: participants,
        CurrentStep:  StepTorpedoAssignment,
        CurrentRound: 1,
        Status:       "active",
        StartTime:    time.Now(),
    }
    
    // Создание тактической карты
    tacticalMap := cm.createTacticalMap(combat)
    cm.TacticalMaps[combat.ID] = tacticalMap
    
    // Размещение юнитов на тактической карте
    cm.placeUnitsOnTacticalMap(combat, tacticalMap)
    
    cm.ActiveCombats[combat.ID] = combat
    cm.CombatSequence = append(cm.CombatSequence, combat.ID)
    
    return combat, nil
}

func (cm *CombatManager) ResolveCombatRound(combatID string) error {
    combat := cm.ActiveCombats[combatID]
    tacticalMap := cm.TacticalMaps[combatID]
    
    // Выполнение шагов боя по порядку
    steps := []CombatStep{
        StepTorpedoAssignment,
        StepFiring,
        StepTorpedoResolution, 
        StepMovement,
        StepAbortAttempt,
        StepReinforcements,
    }
    
    for _, step := range steps {
        combat.CurrentStep = step
        handler := cm.combatServices[step]
        if err := handler.Execute(combat, tacticalMap); err != nil {
            return err
        }
    }
    
    combat.CurrentRound++
    
    // Проверка условий окончания боя
    if cm.shouldCombatEnd(combat) {
        cm.endCombat(combat)
    }
    
    return nil
}
```

### 7.2. Система огня и повреждений в бою

```go
type FiringStepHandler struct {
    gameState *GameState
    combatTables CombatTables
}

func (fsh *FiringStepHandler) Execute(combat *NavalCombat, tacticalMap *TacticalMap) error {
    // Атакующий стреляет первым, затем защищающийся
    attackerUnits := fsh.getAttackerUnits(combat)
    defenderUnits := fsh.getDefenderUnits(combat)
    
    // Огонь атакующего
    for _, unit := range attackerUnits {
        if fsh.canUnitFire(unit, combat) {
            fsh.resolveUnitFire(unit, defenderUnits, combat, tacticalMap)
        }
    }
    
    // Ответный огонь защищающегося
    for _, unit := range defenderUnits {
        if fsh.canUnitFire(unit, combat) {
            fsh.resolveUnitFire(unit, attackerUnits, combat, tacticalMap)
        }
    }
    
    return nil
}

func (fsh *FiringStepHandler) resolveUnitFire(firingUnit *TacticalUnit, targetUnits []*TacticalUnit, combat *NavalCombat, tacticalMap *TacticalMap) {
    // Выбор цели
    target := fsh.selectTarget(firingUnit, targetUnits, tacticalMap)
    if target == nil {
        return // нет доступных целей
    }
    
    // Расчет дистанции
    range := fsh.calculateRange(firingUnit, target, tacticalMap)
    
    // Определение доступного вооружения
    availableWeapons := fsh.getAvailableWeapons(firingUnit, range)
    
    // Расчет модификаторов
    modifiers := fsh.calculateFiringModifiers(firingUnit, target, range, combat)
    
    // Бросок кубов и определение попаданий
    hits := fsh.resolveFiring(firingUnit, target, availableWeapons, modifiers, range)
    
    // Применение повреждений
    fsh.applyDamage(firingUnit, target, hits, combat)
    
    firingUnit.HasFired = true
}

func (fsh *FiringStepHandler) calculateRange(attacker *TacticalUnit, target *TacticalUnit, tacticalMap *TacticalMap) CombatRange {
    attackerPos := tacticalMap.GetPosition(attacker.Position)
    targetPos := tacticalMap.GetPosition(target.Position)
    
    seaZonesBetween := abs(attackerPos.SeaZone - targetPos.SeaZone)
    
    switch {
    case seaZonesBetween <= 1:
        return RangeShort
    case seaZonesBetween <= 3:
        return RangeMedium
    case seaZonesBetween <= 6:
        return RangeLong
    default:
        return RangeExtreme
    }
}
```

## 8. Система очков победы и условий окончания игры

### 8.1. Расчет очков победы

```go
type VictorySystem struct {
    VictoryPoints map[string]int    `json:"victory_points"` // playerID -> VP
    GameEndConditions []GameEndCondition `json:"game_end_conditions"`
}

type VictoryService struct {
    gameState *GameState
    victoryConfig VictoryConfig
}

func (vs *VictoryService) CalculateVictoryPoints() map[string]int {
    vp := make(map[string]int)
    
    // Базовые VP за потопленные корабли
    vs.addShipVP(vp)
    
    // VP за конвои и торговые суда
    vs.addConvoyVP(vp)
    
    // Модификаторы за состояние Bismarck
    vs.addBismarckModifiers(vp)
    
    return vp
}

func (vs *VictoryService) addBismarckModifiers(vp map[string]int) {
    bismarck := vs.gameState.GetUnit("bismarck")
    if bismarck == nil {
        return
    }
    
    germanPlayer := bismarck.Owner
    
    switch {
    case bismarck.IsSunk:
        // Bismarck потоплен - оперативная победа союзников
        vp[germanPlayer] += vs.victoryConfig.BismarckSunkVP
    case bismarck.IsInPort && bismarck.Position == "france_port":
        // Bismarck во Франции
        vp[germanPlayer] += vs.victoryConfig.BismarckFranceVP
    case bismarck.IsInPort && bismarck.Position == "norway_port":
        // Bismarck в Норвегии  
        vp[germanPlayer] += vs.victoryConfig.BismarckNorwayVP
    case bismarck.FuelPoints <= 0:
        // У Bismarck закончилось топливо
        vp[germanPlayer] += vs.victoryConfig.BismarckNoFuelVP
    case vs.isEndOfGameTrack():
        // Конец игрового трека
        vp[germanPlayer] += vs.victoryConfig.BismarckEndGameVP
    }
}

func (vs *VictoryService) CheckGameEnd() (*GameEndResult, error) {
    // Проверка условий окончания игры
    for _, condition := range vs.GameEndConditions {
        if vs.isConditionMet(condition) {
            result := &GameEndResult{
                Condition: condition,
                VictoryPoints: vs.CalculateVictoryPoints(),
                Winner: vs.determineWinner(),
                VictoryType: vs.determineVictoryType(),
            }
            return result, nil
        }
    }
    
    return nil, nil // игра продолжается
}

func (vs *VictoryService) determineWinner() string {
    vp := vs.CalculateVictoryPoints()
    
    // Немецкий игрок должен набрать минимум 1 VP для победы
    germanPlayer := vs.gameState.GetGermanPlayer()
    if vp[germanPlayer] >= 1 {
        return germanPlayer
    }
    
    // Иначе победа союзников
    return vs.gameState.GetAlliedPlayer()
}
```

## 9. Расширенная система конфигурации

### 9.1. Полная конфигурация игры

```json
{
  "game_config": {
    "general": {
      "max_turns": 30,
      "turns_per_day": 3,
      "starting_date": "1941-05-21",
      "time_per_turn_hours": 4.8,
      "max_real_time_minutes": 180
    },
    
    "victory_conditions": {
      "bismarck_sunk": "allied_operational_victory",
      "bismarck_france": -5,
      "bismarck_norway": -7,
      "bismarck_end_game": -10, 
      "bismarck_no_fuel": -15,
      
      "ship_vp_values": {
        "BB": {"sunk": "hull_boxes", "damaged": "half_hits"},
        "CV": {"sunk": "hull_boxes", "damaged": "half_hits"},
        "BC": {"sunk": "hull_boxes", "damaged": "half_hits"},
        "CA": {"sunk": "hull_boxes", "damaged": "half_hits"},
        "others": {"sunk": 1, "damaged": 0}
      },
      
      "convoy_vp": {
        "single_merchant": 0.5,
        "convoy_min": 1,
        "convoy_max": 2,
        "escort_sunk_multiplier": 1.0
      }
    },
    
    "weather": {
      "change_table": [-2, -1, 0, 0, 1, 1, 2, 2, 3, 3],
      "time_modifiers": {
        "morning": 0,
        "afternoon": 0,
        "night": 3
      },
      "fog_threshold": 5,
      "special_fuel_roll_threshold": 9
    },
    
    "movement": {
      "speed_classes": {
        "very_slow": {
          "movement_interval": 4,
          "fuel_cost": 0,
          "no_movement_markers": [4, 3, 2, 1]
        },
        "slow": {
          "movement_interval": 2, 
          "fuel_cost": 0,
          "no_movement_markers": [2, 1]
        },
        "medium": {
          "movement_interval": 1,
          "fuel_cost": {
            "consecutive": 1,
            "alternating": 0
          }
        },
        "fast": {
          "movement_interval": 1,
          "fuel_cost": {
            "zero_or_one_hex": 0,
            "two_hexes_after_zero_or_one": 1,
            "two_hexes_after_two": 2
          },
          "damaged_movement_limit": 1
        }
      },
      
      "restrictions": {
        "german_dd_boundary": ["Q29", "R28", "S27", "T26"],
        "tanker_convoy_hexes": true,
        "kaiser_wilhelm_canal": ["O32", "O33"]
      }
    },
    
    "combat": {
      "max_rounds": 10,
      "reinforcement_start_round": 3,
      "ranges": {
        "short": 1,
        "medium": 2, 
        "long": 4,
        "extreme": 7
      },
      
      "tables": {
        "naval_combat": {
          "ranges": ["extreme", "long", "medium", "short"],
          "dice_multipliers": [0.33, 0.5, 1.0, 1.5],
          "results_table": {...}
        },
        "torpedo_attack": {...},
        "air_attack": {...}
      },
      
      "modifiers": {
        "target_acquired": -1,
        "radar_i": -1,
        "radar_ii": -2,
        "closing_or_breaking_off": +1,
        "vs_closing_or_breaking_off": +1,
        "fire_control_damage": +1,
        "visibility_4_6": +1,
        "visibility_7_9": +3
      }
    },
    
    "search": {
      "base_factors": {
        "ship": 1,
        "task_force": 1,
        "patrol": 3,
        "flight_path": 2
      },
      "max_additional_markers": 2,
      "cost_per_additional_marker": "current_visibility_level"
    },
    
    "repair": {
      "at_sea_table": {
        "0": "+5_evasion_or_rudder_repaired",
        "1": "+3_evasion", 
        "2": "+2_evasion",
        "3-9": "failure"
      },
      "modifiers": {
        "weather_4_6": "+1",
        "weather_7_9": "+2"
      }
    },
    
    "optional_rules": {
      "hypothetical_units": {
        "tirpitz": {"vp_cost": -9, "setup_hex": "O33", "reveal_on": "0-8"},
        "scharnhorst": {"vp_cost": -7, "setup_hex": "U26", "reveal_on": "0-7"},
        "gneisenau": {"vp_cost": -8, "setup_hex": "U26", "reveal_on": "0-5"}
      },
      "crew_exhaustion": true
    }
  }
}
```

## 10. Система реплеев и аналитики

### 10.1. Полная запись игры для реплеев

```go
type GameRecorder struct {
    gameID      string
    snapshots   []*GameSnapshot
    actions     []*ReplayAction
    events      []*GameEvent
    metadata    *ReplayMetadata
}

type GameSnapshot struct {
    ID           string          `json:"id"`
    GameID       string          `json:"game_id"`
    Turn         int             `json:"turn"`
    Phase        GamePhase       `json:"phase"`
    Timestamp    time.Time       `json:"timestamp"`
    Sequence     int             `json:"sequence"`
    FullState    *FullGameState  `json:"full_state"`
    PlayerViews  map[string]*PlayerView `json:"player_views"`
    Action       *ReplayAction   `json:"action,omitempty"`
    KeyEvents    []*GameEvent    `json:"key_events,omitempty"`
}

type FullGameState struct {
    // Полное состояние игры (без тумана войны)
    AllUnits        map[string]*NavalUnit    `json:"all_units"`
    AllAirUnits     map[string]*AirUnit      `json:"all_air_units"`
    AllTaskForces   map[string]*TaskForce    `json:"all_task_forces"`
    AllMarkers      map[string][]*GameMarker `json:"all_markers"`
    Weather         *WeatherState            `json:"weather"`
    ActiveConvoys   map[string]*ConvoyInstance `json:"active_convoys"`
    VictoryPoints   map[string]int           `json:"victory_points"`
    TurnTrack       *TurnTrackState          `json:"turn_track"`
    PhaseTrack      *PhaseTrackState         `json:"phase_track"`
    
    // Мета-информация
    CurrentPlayer   string                   `json:"current_player"`
    GameSettings    *GameSettings            `json:"game_settings"`
    TimeElapsed     int                      `json:"time_elapsed"` // в минутах
}

type ReplayAction struct {
    ID          string          `json:"id"`
    GameID      string          `json:"game_id"`
    PlayerID    string          `json:"player_id"`
    ActionType  ActionType      `json:"action_type"`
    Data        interface{}     `json:"data"`
    Timestamp   time.Time       `json:"timestamp"`
    Phase       GamePhase       `json:"phase"`
    Turn        int             `json:"turn"`
    Sequence    int             `json:"sequence"`
    Validated   bool            `json:"validated"`
    ServerTime  time.Time       `json:"server_time"`
    
    // Для отображения в реплее
    Description string          `json:"description"`
    UIState     *UIStateSnapshot `json:"ui_state,omitempty"`
}

func (gr *GameRecorder) TakeSnapshot(action *ReplayAction) error {
    snapshot := &GameSnapshot{
        ID:        generateSnapshotID(),
        GameID:    gr.gameID,
        Turn:      gr.gameState.CurrentTurn,
        Phase:     gr.gameState.CurrentPhase,
        Timestamp: time.Now(),
        Sequence:  len(gr.snapshots),
        FullState: gr.captureFullState(),
        Action:    action,
    }
    
    // Запись представлений игроков (что видел каждый игрок)
    for _, playerID := range gr.gameState.PlayerIDs {
        snapshot.PlayerViews[playerID] = gr.capturePlayerView(playerID)
    }
    
    gr.snapshots = append(gr.snapshots, snapshot)
    return nil
}

func (gr *GameRecorder) captureFullState() *FullGameState {
    return &FullGameState{
        AllUnits:        gr.deepCopyUnits(gr.gameState.AllUnits),
        AllAirUnits:     gr.deepCopyUnits(gr.gameState.AllAirUnits),
        AllTaskForces:   gr.deepCopyTaskForces(gr.gameState.TaskForces),
        AllMarkers:      gr.deepCopyMarkers(gr.gameState.Markers),
        Weather:         gr.gameState.Weather.Clone(),
        ActiveConvoys:   gr.deepCopyConvoys(gr.gameState.ActiveConvoys),
        VictoryPoints:   copyMap(gr.gameState.VictoryPoints),
        TurnTrack:       gr.gameState.TurnTrack.Clone(),
        PhaseTrack:      gr.gameState.PhaseTrack.Clone(),
        CurrentPlayer:   gr.gameState.CurrentPlayer,
        GameSettings:    gr.gameState.Settings.Clone(),
        TimeElapsed:     gr.gameState.TimeElapsed,
    }
}
```

### 10.2. API для работы с реплеями

```go
type ReplayAPI struct {
    gameService *GameService
    replayStore ReplayStore
}

func (ra *ReplayAPI) GetGameReplay(gameID string) (*GameReplay, error) {
    replay, err := ra.replayStore.GetReplay(gameID)
    if err != nil {
        return nil, err
    }
    
    return replay, nil
}

func (ra *ReplayAPI) GetReplaySnapshot(gameID string, turn int, phase GamePhase, sequence int) (*GameSnapshot, error) {
    replay, err := ra.replayStore.GetReplay(gameID)
    if err != nil {
        return nil, err
    }
    
    for _, snapshot := range replay.Snapshots {
        if snapshot.Turn == turn && snapshot.Phase == phase && snapshot.Sequence == sequence {
            return snapshot, nil
        }
    }
    
    return nil, errors.New("snapshot not found")
}

func (ra *ReplayAPI) GetReplayTimeline(gameID string) (*ReplayTimeline, error) {
    replay, err := ra.replayStore.GetReplay(gameID)
    if err != nil {
        return nil, err
    }
    
    timeline := &ReplayTimeline{
        GameID: gameID,
        Events: []*TimelineEvent{},
    }
    
    for _, snapshot := range replay.Snapshots {
        event := &TimelineEvent{
            Turn:      snapshot.Turn,
            Phase:     snapshot.Phase,
            Timestamp: snapshot.Timestamp,
            Type:      "snapshot",
            Data:      snapshot,
        }
        timeline.Events = append(timeline.Events, event)
    }
    
    for _, action := range replay.Actions {
        event := &TimelineEvent{
            Turn:      action.Turn,
            Phase:     action.Phase,
            Timestamp: action.Timestamp,
            Type:      "action",
            Data:      action,
        }
        timeline.Events = append(timeline.Events, event)
    }
    
    // Сортировка по времени
    sort.Slice(timeline.Events, func(i, j int) bool {
        return timeline.Events[i].Timestamp.Before(timeline.Events[j].Timestamp)
    })
    
    return timeline, nil
}
```

Это полное ТЗ теперь включает все критические системы игры, детализированные модели данных, полные сценарии взаимодействия и все необходимые компоненты для разработки полнофункциональной веб-версии игры "Погоня за Бисмарком".