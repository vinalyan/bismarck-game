# –¢–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –∑–∞–¥–∞–Ω–∏–µ: –í–µ–±-–≤–µ—Ä—Å–∏—è –∏–≥—Ä—ã "–ü–æ–≥–æ–Ω—è –∑–∞ –ë–∏—Å–º–∞—Ä–∫–æ–º" 

## 1. –û–±—â–µ–µ –æ–ø–∏—Å–∞–Ω–∏–µ

### 1.1. –¶–µ–ª—å –ø—Ä–æ–µ–∫—Ç–∞
–†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –º–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π –≤–µ–±-–≤–µ—Ä—Å–∏–∏ –Ω–∞—Å—Ç–æ–ª—å–Ω–æ–π –∏–≥—Ä—ã "–ü–æ–≥–æ–Ω—è –∑–∞ –ë–∏—Å–º–∞—Ä–∫–æ–º" —Å –ø–æ–ª–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π –≤—Å–µ—Ö –∏–≥—Ä–æ–≤—ã—Ö –º–µ—Ö–∞–Ω–∏–∫.

### 1.2. –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
- **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**: Client-Server —Å —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º –ª–æ–≥–∏–∫–∏
- **Backend**: Go (Golang) 
- **Frontend**: –í–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å (HTML/CSS/JavaScript + React/Vue)
- **–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö**: PostgreSQL (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ) + Redis (–∫—ç—à/—Å–µ—Å—Å–∏–∏)
- **–°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ**: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã JSON
- **–ö–æ–º–º—É–Ω–∏–∫–∞—Ü–∏—è**: REST API + WebSocket –¥–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
- **–ú–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —Ä–µ–∂–∏–º**: –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∏–≥—Ä

## 2. –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è

### 2.1. –°–∏—Å—Ç–µ–º–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏

```go
type User struct {
    ID           string    `json:"id"`
    Username     string    `json:"username"`
    PasswordHash string    `json:"-"`
    Email        string    `json:"email"`
    Role         UserRole  `json:"role"`
    Stats        UserStats `json:"stats"`
    CreatedAt    time.Time `json:"created_at"`
    LastLogin    time.Time `json:"last_login"`
}

type UserStats struct {
    GamesPlayed   int     `json:"games_played"`
    GamesWon      int     `json:"games_won"`
    WinRate       float64 `json:"win_rate"`
    FavoriteSide  string  `json:"favorite_side"`
    TotalVP       int     `json:"total_vp"`
    TimePlayed    int     `json:"time_played"` // –≤ –º–∏–Ω—É—Ç–∞—Ö
}
```

**–≠–Ω–¥–ø–æ–∏–Ω—Ç—ã:**
- `POST /api/auth/register` - —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
- `POST /api/auth/login` - –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è  
- `POST /api/auth/logout` - –≤—ã—Ö–æ–¥ –∏–∑ —Å–∏—Å—Ç–µ–º—ã
- `GET /api/user/profile` - –ø–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
- `GET /api/user/stats` - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
- `PUT /api/user/preferences` - –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫
- `GET /api/user/achievements` - –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞

### 2.2. –°–∏—Å—Ç–µ–º–∞ –∏–≥—Ä –∏ –ª–æ–±–±–∏

#### 2.2.1. –ú–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö
```go
type Game struct {
    ID           string       `json:"id"`
    Name         string       `json:"name"`
    Player1ID    string       `json:"player1_id"`  // –ù–µ–º–µ—Ü–∫–∏–π –∏–≥—Ä–æ–∫
    Player2ID    string       `json:"player2_id"`  // –°–æ—é–∑–Ω–∏–∫
    CurrentTurn  int          `json:"current_turn"`
    CurrentPhase GamePhase    `json:"current_phase"`
    GameState    *GameState   `json:"game_state"`
    Status       GameStatus   `json:"status"`
    Settings     GameSettings `json:"settings"`
    CreatedAt    time.Time    `json:"created_at"`
    UpdatedAt    time.Time    `json:"updated_at"`
    CompletedAt  *time.Time   `json:"completed_at,omitempty"`
    Winner       *string      `json:"winner,omitempty"`
    VictoryType  VictoryType  `json:"victory_type,omitempty"`
}

type GameSettings struct {
    UseOptionalUnits      bool           `json:"use_optional_units"`
    EnableCrewExhaustion  bool           `json:"enable_crew_exhaustion"`
    VictoryConditions     VictoryConfig  `json:"victory_conditions"`
    TimeLimitMinutes      int            `json:"time_limit_minutes"`
    PrivateLobby          bool           `json:"private_lobby"`
    Password              string         `json:"password,omitempty"`
    MaxTurnTime           int            `json:"max_turn_time"` // –≤ –º–∏–Ω—É—Ç–∞—Ö
}
```

#### 2.2.2. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–∞–º–∏
**–≠–Ω–¥–ø–æ–∏–Ω—Ç—ã:**
- `GET /api/games` - —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–≥—Ä —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π –∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
- `POST /api/games` - —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∏–≥—Ä—ã
- `POST /api/games/{id}/join` - –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ –∏–≥—Ä–µ
- `GET /api/games/{id}` - –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
- `POST /api/games/{id}/surrender` - —Å–¥–∞—á–∞ –≤ —Ç–µ–∫—É—â–µ–π –∏–≥—Ä–µ
- `POST /api/games/{id}/pause` - –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏–≥—Ä—ã
- `DELETE /api/games/{id}` - —É–¥–∞–ª–µ–Ω–∏–µ –∏–≥—Ä—ã (–µ—Å–ª–∏ –Ω–µ –Ω–∞—á–∞—Ç–∞)
- `GET /api/games/{id}/replay` - –ø–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–ø–ª–µ—è –∏–≥—Ä—ã
- `POST /api/games/{id}/chat` - –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç –∏–≥—Ä—ã

### 2.3. –ò–≥—Ä–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ - —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è

#### 2.3.1. –ü–æ–ª–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ñ–∞–∑
```go
type GamePhase string

const (
    PhaseVisibility    GamePhase = "visibility"
    PhaseShadow        GamePhase = "shadow" 
    PhaseMovement      GamePhase = "movement"
    PhaseSearch        GamePhase = "search"
    PhaseAirAttack     GamePhase = "air_attack"
    PhaseNavalCombat   GamePhase = "naval_combat"
    PhaseChance        GamePhase = "chance"
    PhaseAdmin         GamePhase = "admin"
)

type PhaseManager struct {
    currentPhase GamePhase
    phaseHandlers map[GamePhase]PhaseHandler
    phaseHistory []PhaseRecord
}

type PhaseRecord struct {
    Phase     GamePhase  `json:"phase"`
    Turn      int        `json:"turn"`
    StartTime time.Time  `json:"start_time"`
    EndTime   time.Time  `json:"end_time"`
    Duration  int        `json:"duration"` // –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
}
```

#### 2.3.2. –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –¥–µ–π—Å—Ç–≤–∏–π –∏–≥—Ä–æ–∫–æ–≤
```go
type ActionType string

const (
    ActionMoveUnit         ActionType = "move_unit"
    ActionCreateTF         ActionType = "create_tf"
    ActionSplitTF          ActionType = "split_tf"
    ActionStartRepair      ActionType = "start_repair"
    ActionStartRefuel      ActionType = "start_refuel"
    ActionPatrol           ActionType = "patrol"
    ActionSearch           ActionType = "search"
    ActionAirAttack        ActionType = "air_attack"
    ActionNavalCombat      ActionType = "naval_combat"
    ActionEvasionManeuver  ActionType = "evasion_maneuver"
    ActionDiversionManeuver ActionType = "diversion_maneuver"
    ActionConvoyHunt       ActionType = "convoy_hunt"
    ActionDeclarePort      ActionType = "declare_port"
    ActionAbortCombat      ActionType = "abort_combat"
    ActionAssignTorpedo    ActionType = "assign_torpedo"
    ActionChangePosition   ActionType = "change_position"
)

type GameAction struct {
    ID          string          `json:"id"`
    GameID      string          `json:"game_id"`
    PlayerID    string          `json:"player_id"`
    ActionType  ActionType      `json:"action_type"`
    Data        interface{}     `json:"data"`
    Timestamp   time.Time       `json:"timestamp"`
    Phase       GamePhase       `json:"phase"`
    Turn        int             `json:"turn"`
    Sequence    int             `json:"sequence"`
    CanUndo     bool            `json:"can_undo"`
    Validated   bool            `json:"validated"`
    ServerTime  time.Time       `json:"server_time"`
    Checksum    string          `json:"checksum"` // –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç —á–∏—Ç–µ—Ä—Å—Ç–≤–∞
}
```

## 3. –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –∏–≥—Ä–æ–∫–∞ —Å –∏–≥—Ä–æ–π

### 3.1. –ü—Ä–∏–Ω—Ü–∏–ø—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞

**–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ-–∑–∞–≤–∏—Å–∏–º—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å:**
```typescript
interface UIState {
    currentPhase: GamePhase;
    selectedUnit: Unit | null;
    selectedHex: string | null;
    availableActions: Action[];
    highlightedHexes: Map%3Cstring, HighlightInfo%3E;
    activeTool: ToolMode;
    pendingAction: Action | null;
    undoStack: Action[];
    redoStack: Action[];
}

interface HighlightInfo {
    type: 'movement' | 'search' | 'attack' | 'patrol' | 'invalid';
    reason: string;
    cost?: number;
    factors?: number;
    required?: number;
    units?: Unit[];
}

enum ToolMode {
    SELECT = "select",
    MOVE = "move", 
    SEARCH = "search",
    ATTACK = "attack",
    PATROL = "patrol",
    FORM_TF = "form_tf",
    REPAIR = "repair",
    REFUEL = "refuel"
}
```

### 3.2. –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –≤—ã–±–æ—Ä–∞ —é–Ω–∏—Ç–æ–≤

**–ö–ª–∏–µ–Ω—Ç—Å–∫–∞—è –ª–æ–≥–∏–∫–∞ –≤—ã–±–æ—Ä–∞:**
```typescript
class ClientRuleEngine {
    private gameRules: GameRules;
    private gameState: GameState;
    
    canUnitBeSelected(unit: Unit, phase: GamePhase, player: Player): { canSelect: boolean; reason?: string } {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∞–∑—ã –∏–≥—Ä—ã
        if (!this.isUnitActionAllowedInPhase(unit, phase)) {
            return { canSelect: false, reason: 'action_not_allowed_in_phase' };
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è
        if (unit.owner !== player.id) {
            return { canSelect: false, reason: 'not_your_unit' };
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–Ω—ã—Ö –º–∞—Ä–∫–µ—Ä–æ–≤
        if (unit.hasMarker('no_movement') && this.requiresMovement(phase)) {
            return { canSelect: false, reason: 'unit_cannot_move' };
        }
        
        if (unit.isRepairing && !this.canInterruptRepair(phase)) {
            return { canSelect: false, reason: 'unit_is_repairing' };
        }
        
        if (unit.isRefueling && !this.canInterruptRefuel(phase)) {
            return { canSelect: false, reason: 'unit_is_refueling' };
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
        if (this.isUnitRestricted(unit, phase)) {
            return { canSelect: false, reason: 'unit_is_restricted' };
        }
        
        return { canSelect: true };
    }
    
    getAvailableActionsForUnit(unit: Unit, phase: GamePhase): AvailableAction[] {
        const actions: AvailableAction[] = [];
        
        switch (phase) {
            case 'movement':
                if (this.canMove(unit)) {
                    actions.push({
                        type: 'move',
                        label: '–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å',
                        icon: '‚û°Ô∏è',
                        description: '–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å —é–Ω–∏—Ç –≤ –¥—Ä—É–≥–æ–π –≥–µ–∫—Å'
                    });
                }
                
                if (this.canPatrol(unit)) {
                    actions.push({
                        type: 'patrol',
                        label: '–ü–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞—Ç—å',
                        icon: 'üîÑ', 
                        description: '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–∞—Ç—Ä—É–ª—å –≤ —Ç–µ–∫—É—â–µ–º –≥–µ–∫—Å–µ (+3 –∫ –ø–æ–∏—Å–∫—É)'
                    });
                }
                
                if (this.canRepair(unit)) {
                    actions.push({
                        type: 'repair',
                        label: '–†–µ–º–æ–Ω—Ç –≤ –º–æ—Ä–µ',
                        icon: 'üîß',
                        description: '–ü–æ–ø—ã—Ç–∞—Ç—å—Å—è –ø–æ—á–∏–Ω–∏—Ç—å –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏—è'
                    });
                }
                
                if (this.canRefuel(unit)) {
                    actions.push({
                        type: 'refuel',
                        label: '–î–æ–∑–∞–ø—Ä–∞–≤–∏—Ç—å',
                        icon: '‚õΩ',
                        description: '–î–æ–∑–∞–ø—Ä–∞–≤–∏—Ç—å—Å—è –≤ –ø–æ—Ä—Ç—É –∏–ª–∏ –æ—Ç —Ç–∞–Ω–∫–µ—Ä–∞'
                    });
                }
                
                if (this.canFormTF(unit)) {
                    actions.push({
                        type: 'form_tf',
                        label: '–°–æ–∑–¥–∞—Ç—å –û–°',
                        icon: 'üë•',
                        description: '–û–±—ä–µ–¥–∏–Ω–∏—Ç—å —é–Ω–∏—Ç—ã –≤ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ'
                    });
                }
                break;
                
            case 'search':
                if (this.canSearch(unit)) {
                    actions.push({
                        type: 'search',
                        label: '–ò—Å–∫–∞—Ç—å',
                        icon: 'üîç',
                        description: '–ò—Å–∫–∞—Ç—å –≤—Ä–∞–∂–µ—Å–∫–∏–µ —é–Ω–∏—Ç—ã –≤ –≥–µ–∫—Å–µ'
                    });
                }
                break;
                
            case 'air_attack':
                if (this.canAirAttack(unit)) {
                    actions.push({
                        type: 'air_attack', 
                        label: '–í–æ–∑–¥—É—à–Ω–∞—è –∞—Ç–∞–∫–∞',
                        icon: '‚úàÔ∏è',
                        description: '–ê—Ç–∞–∫–æ–≤–∞—Ç—å –≤—Ä–∞–∂–µ—Å–∫–∏–µ –∫–æ—Ä–∞–±–ª–∏ —Å –≤–æ–∑–¥—É—Ö–∞'
                    });
                }
                break;
                
            case 'naval_combat':
                if (this.canNavalCombat(unit)) {
                    actions.push({
                        type: 'naval_combat',
                        label: '–ú–æ—Ä—Å–∫–æ–π –±–æ–π',
                        icon: 'üí•',
                        description: '–ù–∞—á–∞—Ç—å –º–æ—Ä—Å–∫–æ–π –±–æ–π —Å –≤—Ä–∞–∂–µ—Å–∫–∏–º–∏ —é–Ω–∏—Ç–∞–º–∏'
                    });
                }
                break;
        }
        
        return actions;
    }
}
```

### 3.3. –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –≤—ã–±–æ—Ä–∞ –≥–µ–∫—Å–æ–≤

**–ü–æ–¥—Å–≤–µ—Ç–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≥–µ–∫—Å–æ–≤:**
```typescript
class HexHighlightingSystem {
    private highlightedHexes: Map<string, HighlightInfo> = new Map();
    private pathPreview: string[] = [];
    
    highlightMovementHexes(unit: Unit): void {
        // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –ø–æ–¥—Å–≤–µ—Ç–∫–∏
        this.clearHighlights();
        
        // –†–∞—Å—á–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≥–µ–∫—Å–æ–≤
        const movementRange = this.calculateMovementRange(unit);
        
        movementRange.availableHexes.forEach(hex => {
            const validation = this.validateHexForMovement(unit, hex);
            
            this.highlightedHexes.set(hex, {
                type: validation.valid ? 'movement' : 'invalid',
                reason: validation.reason || 'movement',
                cost: validation.cost,
                units: this.getUnitsInHex(hex)
            });
        });
        
        this.renderHighlights();
    }
    
    highlightSearchHexes(player: Player): void {
        this.clearHighlights();
        
        // –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –≥–µ–∫—Å–æ–≤, –≥–¥–µ –µ—Å—Ç—å —Ñ–∞–∫—Ç–æ—Ä—ã –ø–æ–∏—Å–∫–∞
        const searchableHexes = this.getHexesWithSearchFactors(player);
        
        searchableHexes.forEach(hex => {
            const factors = this.calculateSearchFactors(hex, player);
            const required = this.gameState.weather.visibility;
            
            this.highlightedHexes.set(hex, {
                type: factors >= required ? 'search' : 'invalid',
                reason: 'search',
                factors: factors,
                required: required,
                units: this.getEnemyUnitsInHex(hex, player)
            });
        });
        
        this.renderHighlights();
    }
    
    highlightAttackHexes(unit: AirUnit): void {
        this.clearHighlights();
        
        const attackRange = this.calculateAirAttackRange(unit);
        const enemyHexes = this.getEnemyHexesInRange(attackRange);
        
        enemyHexes.forEach(hex => {
            const hasShadowed = this.hasShadowedEnemy(hex);
            
            if (hasShadowed) {
                this.highlightedHexes.set(hex, {
                    type: 'attack',
                    reason: 'air_attack',
                    units: this.getEnemyUnitsInHex(hex, unit.owner),
                    canAttack: this.canUnitAttackHex(unit, hex)
                });
            }
        });
        
        this.renderHighlights();
    }
    
    showPathPreview(startHex: string, targetHex: string): void {
        const path = this.findPath(startHex, targetHex);
        
        if (path && path.length > 1) {
            this.pathPreview = path;
            
            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø—É—Ç–∏
            path.forEach((hex, index) => {
                const isStart = index === 0;
                const isEnd = index === path.length - 1;
                
                this.highlightedHexes.set(hex, {
                    type: isStart ? 'path_start' : isEnd ? 'path_end' : 'path',
                    reason: 'movement_path',
                    segment: index,
                    isLast: isEnd
                });
            });
            
            this.renderHighlights();
            
            // –ü–æ–∫–∞–∑ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—É—Ç–∏
            this.showPathInfo(path, this.selectedUnit);
        }
    }
}
```

### 3.4. –†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é –¥–µ–π—Å—Ç–≤–∏–π
```typescript
class ContextMenu {
    private position: { x: number, y: number } = { x: 0, y: 0 };
    private target: Unit | string | null = null;
    
    showForUnit(unit: Unit, position: { x: number, y: number }): void {
        this.target = unit;
        this.position = position;
        
        const actions = this.getAvailableActionsForUnit(unit);
        this.renderMenu(actions, position);
    }
    
    showForHex(hexId: string, position: { x: number, y: number }): void {
        this.target = hexId;
        this.position = position;
        
        const actions = this.getAvailableActionsForHex(hexId);
        this.renderMenu(actions, position);
    }
    
    private getAvailableActionsForUnit(unit: Unit): ContextAction[] {
        const actions: ContextAction[] = [];
        const phase = this.gameState.currentPhase;
        
        // –ë–∞–∑–æ–≤—ã–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è
        actions.push({ 
            id: 'unit_info', 
            label: '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —é–Ω–∏—Ç–µ', 
            icon: '‚ÑπÔ∏è',
            category: 'info'
        });
        
        // –î–µ–π—Å—Ç–≤–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ñ–∞–∑—ã
        if (phase === 'movement') {
            if (this.canMove(unit)) {
                actions.push({
                    id: 'move',
                    label: '–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å',
                    icon: '‚û°Ô∏è',
                    category: 'movement',
                    hotkey: 'M'
                });
            }
            
            if (this.canPatrol(unit)) {
                actions.push({
                    id: 'patrol', 
                    label: '–ü–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞—Ç—å',
                    icon: 'üîÑ',
                    category: 'movement',
                    hotkey: 'P'
                });
            }
            
            if (this.canRepair(unit)) {
                actions.push({
                    id: 'repair',
                    label: '–†–µ–º–æ–Ω—Ç –≤ –º–æ—Ä–µ', 
                    icon: 'üîß',
                    category: 'maintenance',
                    hotkey: 'R'
                });
            }
            
            if (this.canRefuel(unit)) {
                actions.push({
                    id: 'refuel',
                    label: '–î–æ–∑–∞–ø—Ä–∞–≤–∏—Ç—å',
                    icon: '‚õΩ',
                    category: 'maintenance', 
                    hotkey: 'F'
                });
            }
        }
        
        if (phase === 'search' && this.canSearch(unit)) {
            actions.push({
                id: 'search',
                label: '–ò—Å–∫–∞—Ç—å –≤—Ä–∞–∂–µ—Å–∫–∏–µ —é–Ω–∏—Ç—ã',
                icon: 'üîç',
                category: 'search',
                hotkey: 'S'
            });
        }
        
        // –î–µ–π—Å—Ç–≤–∏—è —Å –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã–º–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è–º–∏
        if (this.canFormTF(unit)) {
            actions.push({
                id: 'form_tf',
                label: '–°–æ–∑–¥–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ',
                icon: 'üë•',
                category: 'organization',
                hotkey: 'T'
            });
        }
        
        if (this.canSplitTF(unit)) {
            actions.push({
                id: 'split_tf',
                label: '–†–∞–∑–¥–µ–ª–∏—Ç—å –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ', 
                icon: 'üë§',
                category: 'organization',
                hotkey: 'Shift+T'
            });
        }
        
        // –î–µ–π—Å—Ç–≤–∏—è –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö –≤—Ä–∞–∂–µ—Å–∫–∏—Ö —é–Ω–∏—Ç–æ–≤
        if (this.isEnemyUnit(unit) && this.hasVisibility(unit)) {
            actions.push({
                id: 'track_enemy',
                label: '–û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –≤—Ä–∞–∂–µ—Å–∫–∏–π —é–Ω–∏—Ç',
                icon: 'üëÅÔ∏è',
                category: 'intel'
            });
        }
        
        return this.groupActionsByCategory(actions);
    }
    
    private executeAction(action: ContextAction): void {
        switch (action.id) {
            case 'move':
                this.startMovementMode();
                break;
            case 'patrol':
                this.startPatrol();
                break;
            case 'repair':
                this.startRepair();
                break;
            case 'refuel':
                this.startRefuel();
                break;
            case 'search':
                this.performSearch();
                break;
            case 'form_tf':
                this.showTaskForceModal();
                break;
            case 'unit_info':
                this.showUnitInfoModal();
                break;
        }
        
        this.hide();
    }
}
```

## 4. –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –∫–ª–∏–µ–Ω—Ç-—Å–µ—Ä–≤–µ—Ä

### 4.1. –î–µ—Ç–∞–ª—å–Ω–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏

**–ö–ª–∏–µ–Ω—Ç (Frontend):**
```typescript
class GameClient {
    // –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –∑–Ω–∞–Ω–∏—è –æ –ø—Ä–∞–≤–∏–ª–∞—Ö
    private ruleEngine: ClientRuleEngine;
    
    // –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã (—á–∞—Å—Ç–∏—á–Ω–æ–µ)
    private gameState: PartialGameState;
    
    // UI —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    private uiState: UIState;
    
    // –°–µ—Ç–µ–≤–æ–π —Å–ª–æ–π
    private api: GameAPI;
    private websocket: WebSocketClient;
    
    // –û—Å–Ω–æ–≤–Ω—ã–µ –æ–±—è–∑–∞–Ω–Ω–æ—Å—Ç–∏ –∫–ª–∏–µ–Ω—Ç–∞:
    async initialize(): Promise<void> {
        // 1. –ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        await this.loadStaticData();
        
        // 2. –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–≥—Ä–µ
        await this.connectToGame();
        
        // 3. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ UI
        this.setupUI();
        
        // 4. –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
        this.startGameLoop();
    }
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–µ–π—Å—Ç–≤–∏–π –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ
    validateActionLocally(action: GameAction): ValidationResult {
        // –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—á–µ–≤–∏–¥–Ω—ã—Ö –æ—à–∏–±–æ–∫
        return this.ruleEngine.validateAction(action, this.gameState);
    }
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –≤–≤–æ–¥–∞
    handleUserInput(event: UserInputEvent): void {
        switch (event.type) {
            case 'unit_click':
                this.handleUnitClick(event.unitId);
                break;
            case 'hex_click':
                this.handleHexClick(event.hexId);
                break;
            case 'action_click':
                this.handleActionClick(event.actionId);
                break;
            case 'key_press':
                this.handleKeyPress(event.key);
                break;
        }
    }
}
```

**–°–µ—Ä–≤–µ—Ä (Backend):**
```go
type GameServer struct {
    // –ü–æ–ª–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤—Å–µ—Ö –∏–≥—Ä
    games map[string]*Game
    
    // –°–µ—Ä–≤–∏—Å—ã
    actionValidator *ActionValidator
    gameEngine      *GameEngine
    stateManager    *StateManager
    
    // –°–µ—Ç–µ–≤–æ–π —Å–ª–æ–π
    apiServer    *APIServer
    wsHub        *WebsocketHub
    
    // –û—Å–Ω–æ–≤–Ω—ã–µ –æ–±—è–∑–∞–Ω–Ω–æ—Å—Ç–∏ —Å–µ—Ä–≤–µ—Ä–∞:
    func (gs *GameServer) HandleAction(action *GameAction) error {
        // 1. –ü–æ–ª–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –¥–µ–π—Å—Ç–≤–∏—è
        if err := gs.actionValidator.Validate(action); err != nil {
            return err
        }
        
        // 2. –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –∫ —Å–æ—Å—Ç–æ—è–Ω–∏—é –∏–≥—Ä—ã
        newState, err := gs.gameEngine.ApplyAction(action)
        if err != nil {
            return err
        }
        
        // 3. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        if err := gs.stateManager.SaveGameState(action.GameID, newState); err != nil {
            return err
        }
        
        // 4. –†–∞—Å—Å—ã–ª–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –≤—Å–µ–º –∏–≥—Ä–æ–∫–∞–º
        gs.wsHub.BroadcastGameUpdate(action.GameID, newState)
        
        // 5. –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è
        gs.logAction(action)
        
        return nil
    }
    
    // –°–ª–æ–∂–Ω—ã–µ —Ä–∞—Å—á–µ—Ç—ã
    func (gs *GameServer) CalculateMovementRange(unitID string, gameID string) (*MovementRange, error) {
        gameState := gs.getGameState(gameID)
        unit := gameState.GetUnit(unitID)
        
        // –†–∞—Å—á–µ—Ç —Å —É—á–µ—Ç–æ–º –ø–æ–ª–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
        return gs.movementService.CalculateRange(unit, gameState)
    }
}
```

### 4.2. –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –ø—Ä–æ—Ç–æ–∫–æ–ª –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è

**–ù–∞—á–∞–ª–æ –∏–≥—Ä—ã - –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:**
```typescript
interface InitialGameData {
    // –û—Å–Ω–æ–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    gameState: GameState;
    
    // –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
    gameRules: GameRules;
    mapConfig: MapConfig;
    unitDefinitions: Record<string, UnitDef>;
    damageTables: DamageTables;
    weatherTables: WeatherTables;
    combatTables: CombatTables;
    
    // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∏–≥—Ä–æ–∫–∞—Ö
    players: PlayerInfo[];
    currentPlayer: string;
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã
    settings: GameSettings;
    
    // –ú–µ—Ç–∞-–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
    gameId: string;
    turn: number;
    phase: GamePhase;
    startedAt: string;
    timeLimit?: number;
}
```

**–û–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è - –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ:**
```typescript
interface GameStateUpdate {
    type: 'state_update';
    gameId: string;
    sequence: number;
    timestamp: number;
    
    // –ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è
    changes: StateChange[];
    
    // –¢–µ–∫—É—â–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
    currentTurn: number;
    currentPhase: GamePhase;
    activePlayer: string;
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
    phaseTimeRemaining?: number;
    turnTimeRemaining?: number;
}

type StateChange = 
    | UnitMovedChange
    | UnitDamagedChange  
    | MarkerAddedChange
    | MarkerRemovedChange
    | WeatherChangedChange
    | CombatStartedChange
    | CombatEndedChange
    | UnitSunkChange
    | TaskForceCreatedChange
    | TaskForceSplitChange;

interface UnitMovedChange {
    type: 'unit_moved';
    unitId: string;
    fromHex: string;
    toHex: string;
    path: string[];
    fuelCost: number;
    newFuel: number;
}
```

**–ó–∞–ø—Ä–æ—Å—ã –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:**
```typescript
class ServerQueryService {
    // –ó–∞–ø—Ä–æ—Å –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –¥–≤–∏–∂–µ–Ω–∏—è
    async getMovementRange(unitId: string): Promise<MovementRangeResponse> {
        const response = await this.api.get(`/games/${this.gameId}/units/${unitId}/movement-range`);
        return response.data;
    }
    
    // –ó–∞–ø—Ä–æ—Å –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–µ–ª–µ–π –¥–ª—è –∞—Ç–∞–∫–∏
    async getAttackTargets(unitId: string): Promise<AttackTargetsResponse> {
        const response = await this.api.get(`/games/${this.gameId}/units/${unitId}/attack-targets`);
        return response.data;
    }
    
    // –ó–∞–ø—Ä–æ—Å —Ñ–∞–∫—Ç–æ—Ä–æ–≤ –ø–æ–∏—Å–∫–∞ –≤ –≥–µ–∫—Å–µ
    async getSearchInfo(hexId: string): Promise<SearchInfoResponse> {
        const response = await this.api.get(`/games/${this.gameId}/hexes/${hexId}/search-info`);
        return response.data;
    }
    
    // –ó–∞–ø—Ä–æ—Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–æ–µ
    async getCombatInfo(combatId: string): Promise<CombatInfoResponse> {
        const response = await this.api.get(`/games/${this.gameId}/combats/${combatId}`);
        return response.data;
    }
    
    // –ó–∞–ø—Ä–æ—Å –≤–æ–∑–º–æ–∂–Ω—ã—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤
    async getPathOptions(fromHex: string, toHex: string): Promise<PathOptionsResponse> {
        const response = await this.api.get(
            `/games/${this.gameId}/path?from=${fromHex}&to=${toHex}`
        );
        return response.data;
    }
}
```

### 4.3. –ü–æ–ª–Ω—ã–π —Ü–∏–∫–ª –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –Ω–∞ –ø—Ä–∏–º–µ—Ä–µ –¥–≤–∏–∂–µ–Ω–∏—è

```typescript
// 1. –ò–≥—Ä–æ–∫ –≤—ã–±–∏—Ä–∞–µ—Ç —é–Ω–∏—Ç
async onUnitSelected(unitId: string): Promise<void> {
    // –ö–ª–∏–µ–Ω—Ç—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
    const unit = this.gameState.getUnit(unitId);
    const validation = this.ruleEngine.canUnitBeSelected(unit, this.gameState.currentPhase, this.currentPlayer);
    
    if (!validation.canSelect) {
        this.showError(validation.reason!);
        return;
    }
    
    // –í—ã–±–æ—Ä —é–Ω–∏—Ç–∞
    this.selectUnit(unitId);
    
    // –ó–∞–ø—Ä–æ—Å –∫ —Å–µ—Ä–≤–µ—Ä—É –¥–ª—è —Ç–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    await this.loadUnitActions(unitId);
}

// 2. –ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π
async loadUnitActions(unitId: string): Promise<void> {
    try {
        this.showLoading('–ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π...');
        
        // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
        const [movementRange, attackTargets, searchInfo] = await Promise.all([
            this.queries.getMovementRange(unitId),
            this.queries.getAttackTargets(unitId),
            this.queries.getSearchInfo(this.selectedHex)
        ]);
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI —Å –ø–æ–ª—É—á–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
        this.updateUIWithAvailableActions({
            movementRange,
            attackTargets, 
            searchInfo
        });
        
    } catch (error) {
        this.showError('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö');
    } finally {
        this.hideLoading();
    }
}

// 3. –ò–≥—Ä–æ–∫ –≤—ã–±–∏—Ä–∞–µ—Ç –¥–µ–π—Å—Ç–≤–∏–µ - –¥–≤–∏–∂–µ–Ω–∏–µ
onMoveActionSelected(): void {
    this.setToolMode(ToolMode.MOVE);
    
    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≥–µ–∫—Å–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
    this.highlightMovementHexes(this.movementRange.availableHexes);
    
    // –ü–æ–∫–∞–∑ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –¥–≤–∏–∂–µ–Ω–∏–∏
    this.showMovementInfo(this.selectedUnit, this.movementRange);
}

// 4. –ò–≥—Ä–æ–∫ –≤—ã–±–∏—Ä–∞–µ—Ç —Ü–µ–ª–µ–≤–æ–π –≥–µ–∫—Å
onHexSelectedForMovement(hexId: string): void {
    if (!this.isHexHighlighted(hexId)) return;
    
    // –†–∞—Å—á–µ—Ç –ø—É—Ç–∏ (–º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ –∏–ª–∏ —Å–µ—Ä–≤–µ—Ä–µ)
    const path = this.findPath(this.selectedUnit.position, hexId);
    
    if (!path) {
        this.showError('–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –º–∞—Ä—à—Ä—É—Ç');
        return;
    }
    
    // –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ø—É—Ç–∏ –∏ —Å—Ç–æ–∏–º–æ—Å—Ç–∏
    this.showPathPreview(path);
    this.showMovementCost(this.calculateMovementCost(path));
    
    // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è
    this.showConfirmationDialog({
        title: '–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è',
        message: `–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å ${this.selectedUnit.name} –≤ –≥–µ–∫—Å ${hexId}?`,
        onConfirm: () => this.executeMoveAction(path),
        onCancel: () => this.cancelMovement()
    });
}

// 5. –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä
async executeMoveAction(path: string[]): Promise<void> {
    const action: MoveAction = {
        type: 'move_unit',
        unitId: this.selectedUnit.id,
        path: path,
        targetHex: path[path.length - 1],
        playerId: this.currentPlayer.id,
        timestamp: Date.now(),
        turn: this.gameState.turn,
        phase: this.gameState.currentPhase
    };
    
    try {
        // –ö–ª–∏–µ–Ω—Ç—Å–∫–∞—è –ø—Ä–µ–¥-–≤–∞–ª–∏–¥–∞—Ü–∏—è
        const localValidation = this.validateActionLocally(action);
        if (!localValidation.valid) {
            this.showError(localValidation.reason!);
            return;
        }
        
        // –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        const response = await this.api.sendAction(action);
        
        if (response.success) {
            // –î–µ–π—Å—Ç–≤–∏–µ —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–æ
            this.showSuccess('–Æ–Ω–∏—Ç —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω');
            this.clearSelection();
        } else {
            // –°–µ—Ä–≤–µ—Ä –æ—Ç–∫–ª–æ–Ω–∏–ª –¥–µ–π—Å—Ç–≤–∏–µ
            this.showError(response.error!);
        }
        
    } catch (error) {
        this.showError('–û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–µ–π—Å—Ç–≤–∏—è');
    }
}

// 6. –°–µ—Ä–≤–µ—Ä–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ (–±–µ–∫–µ–Ω–¥)
func (gs *GameServer) handleMoveAction(action *MoveAction) (*ActionResult, error) {
    // –ü–æ–ª–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
    validation := gs.actionValidator.ValidateMoveAction(action, gs.gameState)
    if !validation.Valid {
        return nil, errors.New(validation.Reason)
    }
    
    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è
    newState, err := gs.gameEngine.ApplyMoveAction(action, gs.gameState)
    if err != nil {
        return nil, err
    }
    
    // –†–∞—Å—Å—ã–ª–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
    update := gs.createStateUpdate(gs.gameState, newState, []StateChange{
        {
            Type: "unit_moved",
            UnitID: action.UnitID,
            FromHex: oldPosition,
            ToHex: action.TargetHex,
            Path: action.Path,
            FuelCost: calculatedCost,
        },
    })
    
    gs.wsHub.Broadcast(update)
    
    return &ActionResult{Success: true, Update: update}, nil
}
```

## 5. –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏–≥—Ä–æ–≤—ã–µ —Å–∏—Å—Ç–µ–º—ã

### 5.1. –ü–æ–ª–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —é–Ω–∏—Ç–æ–≤

```go
type NavalUnit struct {
    ID           string          `json:"id"`
    Name         string          `json:"name"`
    Type         UnitType        `json:"type"`
    Class        string          `json:"class"`
    Owner        string          `json:"owner"`
    Nationality  string          `json:"nationality"`
    Position     string          `json:"position"`
    Evasion      int             `json:"evasion"`
    BaseEvasion  int             `json:"base_evasion"`
    SpeedRating  SpeedType       `json:"speed_rating"`
    Radar        RadarType       `json:"radar"`
    FuelPoints   int             `json:"fuel_points"`
    MaxFuel      int             `json:"max_fuel"`
    IsDamaged    bool            `json:"is_damaged"`
    
    // –¢–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
    PrimaryArmamentBow   int `json:"primary_armament_bow"`
    PrimaryArmamentStern int `json:"primary_armament_stern"`
    SecondaryArmament    int `json:"secondary_armament"`
    Torpedoes           int `json:"torpedoes"`
    MaxTorpedoes        int `json:"max_torpedoes"`
    HullPoints          int `json:"hull_points"`
    MaxHullPoints       int `json:"max_hull_points"`
    
    // –°—Ç–∞—Ç—É—Å–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã
    Markers      []UnitMarker    `json:"markers"`
    Damage       []Damage        `json:"damage"`
    EvasionEffects []EvasionEffect `json:"evasion_effects"`
    
    // –ò—Å—Ç–æ—Ä–∏—è –¥–≤–∏–∂–µ–Ω–∏–π –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Ç–æ–ø–ª–∏–≤–∞
    MovementHistory []MovementRecord `json:"movement_history"`
    
    // –§–ª–∞–≥ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç–∏ –∫ TF
    TaskForceID  *string         `json:"task_force_id,omitempty"`
    
    // –í—Ä–µ–º–µ–Ω–Ω—ã–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã
    TemporaryModifiers []UnitModifier `json:"temporary_modifiers"`
}

type AirUnit struct {
    ID            string        `json:"id"`
    Name          string        `json:"name"`
    Type          AirUnitType   `json:"type"`
    Owner         string        `json:"owner"`
    Position      string        `json:"position"`
    BasePosition  string        `json:"base_position"`
    MaxSpeed      int           `json:"max_speed"`
    Endurance     int           `json:"endurance"`
    CurrentFuel   int           `json:"current_fuel"`
    SearchFactors int           `json:"search_factors"`
    
    // –°—Ç–∞—Ç—É—Å
    Status        AirUnitStatus `json:"status"`
    RefitTurns    int           `json:"refit_turns"`
    
    // –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
    Capabilities  AirCapabilities `json:"capabilities"`
    
    // –ú–∞—Ä–∫–µ—Ä—ã –ø—É—Ç–∏ –ø–æ–ª–µ—Ç–∞
    FlightPathMarkers []FlightPathMarker `json:"flight_path_markers"`
}

type TaskForce struct {
    ID          string   `json:"id"`
    Name        string   `json:"name"`
    Owner       string   `json:"owner"`
    Position    string   `json:"position"`
    Units       []string `json:"unit_ids"`
    Marker      string   `json:"marker"`
    SpeedRating SpeedType `json:"speed_rating"` // –ø–æ —Å–∞–º–æ–º—É –º–µ–¥–ª–µ–Ω–Ω–æ–º—É —é–Ω–∏—Ç—É
}
```

### 5.2. –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–æ–≥–æ–¥—ã –∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏

```go
type WeatherSystem struct {
    CurrentWeather  WeatherState     `json:"current_weather"`
    WeatherTrack    int              `json:"weather_track"` // 0-9
    History         []WeatherRecord  `json:"history"`
    Forecast        []WeatherPrediction `json:"forecast"`
}

type WeatherState struct {
    Level          int       `json:"level"` // 0-9
    IsFog          bool      `json:"is_fog"`
    Visibility     int       `json:"visibility"` // 1-9 –∏–ª–∏ 10 (X)
    TimeOfDay      TimeOfDay `json:"time_of_day"`
    DayNumber      int       `json:"day_number"`
    TurnInDay      int       `json:"turn_in_day"`
    Date           string    `json:"date"` // "1941-05-24"
}

type TimeOfDay string
const (
    TimeMorning   TimeOfDay = "morning"
    TimeAfternoon TimeOfDay = "afternoon" 
    TimeNight     TimeOfDay = "night"
)

// –°–µ—Ä–≤–∏—Å –ø–æ–≥–æ–¥—ã
type WeatherService struct {
    gameState *GameState
    changeTable []int // [-2, -1, 0, 0, 1, 1, 2, 2, 3, 3]
    
    func (ws *WeatherService) UpdateWeather() error {
        // –ë—Ä–æ—Å–æ–∫ –Ω–∞ —Ç–∞–±–ª–∏—Ü–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–≥–æ–¥—ã
        roll := ws.rollWeatherChange()
        newTrack := ws.calculateNewTrack(roll)
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        ws.updateWeatherState(newTrack)
        ws.calculateVisibility()
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Å–æ–±—ã—Ö —É—Å–ª–æ–≤–∏–π
        if ws.CurrentWeather.Level == 9 {
            ws.checkSpecialFuelExpenditure()
        }
        
        // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
        ws.recordWeatherChange()
        
        return nil
    }
    
    func (ws *WeatherService) calculateVisibility() int {
        weatherLevel := ws.CurrentWeather.Level
        timeModifier := ws.getTimeOfDayModifier()
        visibility := weatherLevel + timeModifier
        
        // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ —Å–æ–≥–ª–∞—Å–Ω–æ –ø—Ä–∞–≤–∏–ª–∞–º
        if visibility > 9 {
            return 10 // X - –Ω–∏–∫–∞–∫–æ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏
        }
        
        // –£—á–µ—Ç —Ç—É–º–∞–Ω–∞
        if ws.CurrentWeather.IsFog {
            visibility = 10 // X –≤ —Ç—É–º–∞–Ω–µ
        }
        
        return visibility
    }
    
    func (ws *WeatherService) getTimeOfDayModifier() int {
        switch ws.CurrentWeather.TimeOfDay {
        case TimeMorning, TimeAfternoon:
            return 0
        case TimeNight:
            return 3
        default:
            return 0
        }
    }
}
```

### 5.3. –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–æ–∏—Å–∫–∞ –∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è

```go
type SearchSystem struct {
    SearchFactors  map[string]int          `json:"search_factors"` // hex -> factors
    SearchResults  map[string]SearchResult `json:"search_results"`
    DetectionHistory []DetectionRecord     `json:"detection_history"`
}

type SearchService struct {
    gameState *GameState
    searchTables SearchTables
}

func (ss *SearchService) PerformSearch(hexID string, playerID string) (*SearchResult, error) {
    // –†–∞—Å—á–µ—Ç —Ñ–∞–∫—Ç–æ—Ä–æ–≤ –ø–æ–∏—Å–∫–∞
    factors := ss.calculateSearchFactors(hexID, playerID)
    required := ss.gameState.Weather.Visibility
    
    if factors < required {
        return &SearchResult{
            Success: false, 
            Factors: factors,
            Required: required,
            Reason: "insufficient_search_factors"
        }, nil
    }
    
    // –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —é–Ω–∏—Ç–æ–≤
    detectedUnits := ss.detectUnitsInHex(hexID, playerID)
    
    if len(detectedUnits) == 0 {
        return &SearchResult{
            Success: true,
            Factors: factors,
            DetectedUnits: []DetectedUnit{},
            MarkerType: "", // –Ω–µ—Ç —é–Ω–∏—Ç–æ–≤ –¥–ª—è –º–∞—Ä–∫–∏—Ä–æ–≤–∫–∏
        }, nil
    }
    
    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –º–∞—Ä–∫–µ—Ä–∞ (Sighted/Shadowed)
    markerType := ss.determineMarkerType(hexID, playerID)
    
    result := &SearchResult{
        Success:       true,
        Factors:       factors,
        DetectedUnits: detectedUnits,
        MarkerType:    markerType,
        HexID:         hexID,
        PlayerID:      playerID,
    }
    
    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞
    ss.applySearchResults(result)
    
    return result, nil
}

func (ss *SearchService) calculateSearchFactors(hexID string, playerID string) int {
    factors := 0
    
    // –ë–∞–∑–æ–≤—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã –≥–µ–∫—Å–∞
    hex := ss.gameState.Map.GetHex(hexID)
    factors += hex.IntrinsicSearch
    
    // –Æ–Ω–∏—Ç—ã –≤ –≥–µ–∫—Å–µ
    units := ss.gameState.GetUnitsInHex(hexID)
    for _, unit := range units {
        if unit.Owner == playerID && unit.CanContributeSearch() {
            factors += 1 // –∫–∞–∂–¥—ã–π —Å–≤–æ–π —é–Ω–∏—Ç –¥–∞–µ—Ç +1
        }
    }
    
    // –ú–∞—Ä–∫–µ—Ä—ã –ø–∞—Ç—Ä—É–ª—è
    if patrolMarkers := ss.gameState.GetMarkersInHex(hexID, "patrol"); len(patrolMarkers) > 0 {
        factors += 3 // –∫–∞–∂–¥—ã–π –º–∞—Ä–∫–µ—Ä –ø–∞—Ç—Ä—É–ª—è –¥–∞–µ—Ç +3
    }
    
    // –ú–∞—Ä–∫–µ—Ä—ã –ø—É—Ç–∏ –ø–æ–ª–µ—Ç–∞
    if flightMarkers := ss.gameState.GetMarkersInHex(hexID, "flight_path_search"); len(flightMarkers) > 0 {
        factors += len(flightMarkers) * 2 // –∫–∞–∂–¥—ã–π –º–∞—Ä–∫–µ—Ä –¥–∞–µ—Ç +2
    }
    
    return factors
}

func (ss *SearchService) detectUnitsInHex(hexID string, playerID string) []DetectedUnit {
    var detected []DetectedUnit
    units := ss.gameState.GetUnitsInHex(hexID)
    
    for _, unit := range units {
        // –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–≤–æ–∏ —é–Ω–∏—Ç—ã
        if unit.Owner == playerID {
            continue
        }
        
        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —é–Ω–∏—Ç–µ
        detectionLevel := ss.determineDetectionLevel(unit, playerID)
        
        detectedUnit := DetectedUnit{
            UnitID:    unit.ID,
            UnitType:  unit.Type,
            IsInTF:    unit.TaskForceID != nil,
            ExactType: detectionLevel == "exact",
            Confidence: ss.calculateConfidence(unit, playerID),
        }
        
        // –î–ª—è –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π - –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        if unit.TaskForceID != nil {
            tf := ss.gameState.GetTaskForce(*unit.TaskForceID)
            detectedUnit.TFSize = len(tf.Units)
            detectedUnit.TFComposition = ss.analyzeTFComposition(tf, playerID)
        }
        
        detected = append(detected, detectedUnit)
    }
    
    return detected
}
```


## 6. –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏–≥—Ä–æ–≤—ã–µ —Å–∏—Å—Ç–µ–º—ã (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)

### 6.1. –°–∏—Å—Ç–µ–º–∞ –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π (Task Forces)

```go
type TaskForceSystem struct {
    TaskForces map[string]*TaskForce `json:"task_forces"`
    TFCounters map[string]int        `json:"tf_counters"` // –¥–ª—è –Ω—É–º–µ—Ä–∞—Ü–∏–∏
}

type TaskForceService struct {
    gameState *GameState
}

func (tfs *TaskForceService) CreateTaskForce(unitIDs []string, position string, playerID string) (*TaskForce, error) {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –≤—Å–µ —é–Ω–∏—Ç—ã –≤ –æ–¥–Ω–æ–º –≥–µ–∫—Å–µ
    if !tfs.areUnitsInSameHex(unitIDs, position) {
        return nil, errors.New("units must be in the same hex to form TF")
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ —é–Ω–∏—Ç—ã –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –∏–≥—Ä–æ–∫—É
    for _, unitID := range unitIDs {
        unit := tfs.gameState.GetUnit(unitID)
        if unit.Owner != playerID {
            return nil, errors.New("all units must belong to the player")
        }
        if unit.IsShadowed {
            return nil, errors.New("cannot form TF with shadowed units")
        }
    }
    
    // –°–æ–∑–¥–∞–Ω–∏–µ TF
    tf := &TaskForce{
        ID:        tfs.generateTFID(),
        Name:      tfs.generateTFName(playerID),
        Owner:     playerID,
        Position:  position,
        Units:     unitIDs,
        CreatedAt: time.Now(),
    }
    
    // –†–∞—Å—á–µ—Ç —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ TF
    tfs.calculateTFProperties(tf)
    
    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ TF –∫ —Å–æ—Å—Ç–æ—è–Ω–∏—é –∏–≥—Ä—ã
    tfs.applyTFToGameState(tf)
    
    return tf, nil
}

func (tfs *TaskForceService) calculateTFProperties(tf *TaskForce) {
    // –°–∫–æ—Ä–æ—Å—Ç—å TF –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Å–∞–º—ã–º –º–µ–¥–ª–µ–Ω–Ω—ã–º –∫–æ—Ä–∞–±–ª–µ–º
    minSpeed := SpeedFast
    for _, unitID := range tf.Units {
        unit := tfs.gameState.GetUnit(unitID)
        if unit.SpeedRating < minSpeed {
            minSpeed = unit.SpeedRating
        }
    }
    tf.SpeedRating = minSpeed
    
    // –≠–º–±–ª–µ–º–∞ TF
    tf.Marker = tfs.generateTFMarker(tf.Owner)
}

func (tfs *TaskForceService) SplitTaskForce(tfID string, unitsToRemove []string, playerID string) error {
    tf := tfs.gameState.GetTaskForce(tfID)
    if tf.Owner != playerID {
        return errors.New("not your task force")
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ TF –Ω–µ shadowed
    if tf.IsShadowed {
        return errors.New("cannot split shadowed TF")
    }
    
    // –£–¥–∞–ª–µ–Ω–∏–µ —é–Ω–∏—Ç–æ–≤ –∏–∑ TF
    remainingUnits := []string{}
    for _, unitID := range tf.Units {
        if !contains(unitsToRemove, unitID) {
            remainingUnits = append(remainingUnits, unitID)
        }
    }
    
    if len(remainingUnits) < 2 {
        // –ï—Å–ª–∏ –æ—Å—Ç–∞–ª–æ—Å—å –º–µ–Ω—å—à–µ 2 —é–Ω–∏—Ç–æ–≤, —Ä–∞—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å TF
        tfs.disbandTaskForce(tfID)
    } else {
        // –û–±–Ω–æ–≤–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π TF
        tf.Units = remainingUnits
        tfs.calculateTFProperties(tf)
    }
    
    // –í–µ—Ä–Ω—É—Ç—å —É–¥–∞–ª–µ–Ω–Ω—ã–µ —é–Ω–∏—Ç—ã –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    for _, unitID := range unitsToRemove {
        unit := tfs.gameState.GetUnit(unitID)
        unit.TaskForceID = nil
        unit.Position = tf.Position // –æ—Å—Ç–∞—é—Ç—Å—è –≤ —Ç–æ–º –∂–µ –≥–µ–∫—Å–µ
    }
    
    return nil
}
```

### 6.2. –°–∏—Å—Ç–µ–º–∞ –∫–æ–Ω–≤–æ–µ–≤ –∏ –æ—Ö–æ—Ç—ã

```go
type ConvoySystem struct {
    ActiveConvoys   map[string]*ConvoyInstance `json:"active_convoys"`
    SpawnSchedule   map[int][]string           `json:"spawn_schedule"` // turn -> convoy IDs
    HuntedConvoys   map[string]bool            `json:"hunted_convoys"`
    ConvoyRoutes    map[string]ConvoyRoute     `json:"convoy_routes"`
}

type ConvoyService struct {
    gameState *GameState
    convoyConfig ConvoyConfig
}

func (cs *ConvoyService) SpawnConvoys(turn int) error {
    convoyIDs, exists := cs.SpawnSchedule[turn]
    if !exists {
        return nil // –Ω–µ—Ç –∫–æ–Ω–≤–æ–µ–≤ –¥–ª—è —ç—Ç–æ–≥–æ —Ö–æ–¥–∞
    }
    
    for _, convoyID := range convoyIDs {
        route := cs.ConvoyRoutes[convoyID]
        convoy := &ConvoyInstance{
            ID:          convoyID,
            RouteID:     route.ID,
            CurrentHex:  route.StartHex,
            Composition: route.DefaultComposition,
            Escorts:     route.Escorts,
            Value:       route.Value,
            Status:      "active",
            SpawnTurn:   turn,
        }
        
        cs.ActiveConvoys[convoyID] = convoy
        cs.placeConvoyOnMap(convoy)
    }
    
    return nil
}

func (cs *ConvoyService) HuntConvoys(huntingUnitID string, playerID string) (*ConvoyHuntResult, error) {
    huntingUnit := cs.gameState.GetUnit(huntingUnitID)
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –æ—Ö–æ—Ç—ã
    if !cs.canHuntConvoys(huntingUnit, playerID) {
        return nil, errors.New("unit cannot hunt convoys")
    }
    
    // –ë—Ä–æ—Å–æ–∫ –Ω–∞ —Ç–∞–±–ª–∏—Ü–µ –æ—Ö–æ—Ç—ã
    roll := cs.rollConvoyHunt()
    modifiedRoll := cs.applyHuntModifiers(roll, huntingUnit)
    
    result := &ConvoyHuntResult{
        Roll: roll,
        ModifiedRoll: modifiedRoll,
        HuntingUnit: huntingUnitID,
    }
    
    switch {
    case modifiedRoll == 0:
        // –í–æ–∑–º–æ–∂–Ω—ã–π –∫–æ–Ω—Ç–∞–∫—Ç —Å –∫–æ–Ω–≤–æ–µ–º
        convoy := cs.findConvoyInRange(huntingUnit.Position)
        if convoy != nil {
            result.ConvoyContact = convoy
            result.ConvoyFound = true
        }
    case modifiedRoll == 1:
        // –û–¥–∏–Ω–æ—á–Ω–æ–µ —Ç–æ—Ä–≥–æ–≤–æ–µ —Å—É–¥–Ω–æ
        result.SingleMerchant = true
        result.VP = 0.5
    default:
        // –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
        result.NothingFound = true
    }
    
    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ—Ö–æ—Ç—ã
    cs.applyHuntResults(result, huntingUnit)
    
    return result, nil
}

func (cs *ConvoyService) canHuntConvoys(unit *NavalUnit, playerID string) bool {
    // –¢–æ–ª—å–∫–æ –Ω–µ–º–µ—Ü–∫–∏–µ BB, BC, CA –º–æ–≥—É—Ç –æ—Ö–æ—Ç–∏—Ç—å—Å—è –Ω–∞ –∫–æ–Ω–≤–æ–∏
    if unit.Owner != "german" {
        return false
    }
    
    if unit.Type != "BB" && unit.Type != "BC" && unit.Type != "CA" {
        return false
    }
    
    // –ù–µ–ª—å–∑—è –æ—Ö–æ—Ç–∏—Ç—å—Å—è –µ—Å–ª–∏ shadowed
    if unit.IsShadowed {
        return false
    }
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∏–∑ –ø—Ä–∞–≤–∏–ª
    if unit.HasReducedEvasion && cs.isUnitHeadedToPort(unit) {
        return false
    }
    
    // –î–æ–ª–∂–µ–Ω –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –Ω–∞ –º–∞—Ä—à—Ä—É—Ç–µ –∫–æ–Ω–≤–æ—è –≤–Ω–µ –≥—Ä–∞–Ω–∏—Ü –∞–≤–∏–∞—Ü–∏–∏
    return cs.isOnConvoyRoute(unit.Position) && cs.isOutsideAirBoundaries(unit.Position)
}
```

### 6.3. –°–∏—Å—Ç–µ–º–∞ –ø–æ–¥–≤–æ–¥–Ω—ã—Ö –ª–æ–¥–æ–∫

```go
type SubmarineSystem struct {
    ContactSchedule map[int]bool              `json:"contact_schedule"` // turn -> –∏–º–µ–µ—Ç –ª–∏ –∫–æ–Ω—Ç–∞–∫—Ç
    SubmarineTypes  map[string]SubmarineType  `json:"submarine_types"`
}

type SubmarineService struct {
    gameState *GameState
}

func (ss *SubmarineService) CheckSubmarineContact(turn int) (*SubmarineContact, error) {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å—Ç—å –ª–∏ –∫–æ–Ω—Ç–∞–∫—Ç –≤ —ç—Ç–æ—Ç —Ö–æ–¥
    hasContact, exists := ss.ContactSchedule[turn]
    if !exists || !hasContact {
        return nil, nil // –Ω–µ—Ç –∫–æ–Ω—Ç–∞–∫—Ç–∞ –≤ —ç—Ç–æ—Ç —Ö–æ–¥
    }
    
    // –ë—Ä–æ—Å–æ–∫ –Ω–∞ —Ç–∞–±–ª–∏—Ü–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞
    contactRoll := ss.rollSubmarineContact()
    if contactRoll > 2 { // 0-2 —É—Å–ø–µ—Ö, 3-9 –ø—Ä–æ–≤–∞–ª
        return nil, nil
    }
    
    // –ë—Ä–æ—Å–æ–∫ –Ω–∞ —Ç–∞–±–ª–∏—Ü–µ –∞—Ç–∞–∫–∏
    attackRoll := ss.rollSubmarineAttack()
    
    contact := &SubmarineContact{
        Turn:       turn,
        ContactRoll: contactRoll,
        AttackRoll: attackRoll,
    }
    
    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –ø–æ–¥–ª–æ–¥–∫–∏ –∏ —Ü–µ–ª–µ–π
    switch {
    case attackRoll == 0:
        // –°–æ—é–∑–Ω–∞—è –ø–æ–¥–ª–æ–¥–∫–∞ –∞—Ç–∞–∫—É–µ—Ç –Ω–µ–º–µ—Ü–∫–∏–µ –∫–æ—Ä–∞–±–ª–∏
        contact.SubmarineType = "allied"
        contact.Target = ss.findGermanTarget()
    case attackRoll >= 1 && attackRoll <= 6:
        // –ù–µ–º–µ—Ü–∫–∞—è –ø–æ–¥–ª–æ–¥–∫–∞ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç —Å–æ—é–∑–Ω—ã–µ –∫–æ—Ä–∞–±–ª–∏
        contact.SubmarineType = "german"
        contact.Target = ss.findAlliedTarget()
    case attackRoll >= 7 && attackRoll <= 9:
        // –ù–µ–º–µ—Ü–∫–∞—è –ø–æ–¥–ª–æ–¥–∫–∞ –∞—Ç–∞–∫—É–µ—Ç —Å–æ—é–∑–Ω—ã–µ –∫–æ—Ä–∞–±–ª–∏
        contact.SubmarineType = "german"
        contact.Target = ss.findAlliedTarget()
        contact.WillAttack = true
    }
    
    // –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ –∫–æ–Ω—Ç–∞–∫—Ç–∞
    ss.resolveSubmarineContact(contact)
    
    return contact, nil
}

func (ss *SubmarineService) resolveSubmarineContact(contact *SubmarineContact) {
    if contact.WillAttack {
        // –ü—Ä–æ–≤–µ–¥–µ–Ω–∏–µ —Ç–æ—Ä–ø–µ–¥–Ω–æ–π –∞—Ç–∞–∫–∏
        attackResult := ss.resolveTorpedoAttack(contact.Target, "submarine")
        contact.AttackResult = attackResult
        
        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–π
        if attackResult.Hits > 0 {
            ss.applyDamage(contact.Target, attackResult.Damage)
        }
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–∏
    ss.updateDetection(contact)
}
```

### 6.4. –°–∏—Å—Ç–µ–º–∞ —Å–ª—É—á–∞–π–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π (Random Spotting)

```go
type RandomSpottingSystem struct {
    SpottingTable RandomSpottingTable `json:"spotting_table"`
}

type SpottingService struct {
    gameState *GameState
}

func (ss *SpottingService) PerformRandomSpotting() []*SpottingResult {
    var results []*SpottingResult
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –Ω–µ–º–µ—Ü–∫–æ–≥–æ —é–Ω–∏—Ç–∞/TF
    germanUnits := ss.gameState.GetGermanUnits()
    
    for _, unit := range germanUnits {
        // –î–ª—è TF - –æ–¥–∏–Ω –±—Ä–æ—Å–æ–∫ –Ω–∞ –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        if unit.TaskForceID != nil {
            tf := ss.gameState.GetTaskForce(*unit.TaskForceID)
            if ss.alreadyCheckedTF(tf.ID) {
                continue
            }
            result := ss.checkSpottingForTF(tf)
            results = append(results, result)
            continue
        }
        
        // –î–ª—è –æ–¥–∏–Ω–æ—á–Ω—ã—Ö —é–Ω–∏—Ç–æ–≤
        result := ss.checkSpottingForUnit(unit)
        results = append(results, result)
    }
    
    return results
}

func (ss *SpottingService) checkSpottingForUnit(unit *NavalUnit) *SpottingResult {
    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ –ø–æ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—é
    column := ss.determineSpottingColumn(unit.Position)
    
    // –ë—Ä–æ—Å–æ–∫ –Ω–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ
    roll := ss.rollSpotting()
    spottingValue := ss.SpottingTable.GetValue(column, ss.gameState.Weather.Visibility)
    
    result := &SpottingResult{
        UnitID: unit.ID,
        Position: unit.Position,
        Roll: roll,
        SpottingValue: spottingValue,
        Column: column,
    }
    
    if roll == 0 {
        // Huff-Duff - —Ç–æ–ª—å–∫–æ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ
        result.HuffDuff = true
        result.LocationRevealed = true
    } else if roll <= spottingValue {
        // –ü–æ–ª–Ω–æ–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ
        result.FullyLocated = true
        result.LocationRevealed = true
        result.UnitInfoRevealed = true
    }
    
    return result
}
```

## 7. –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —Ç–∞–∫—Ç–∏—á–µ—Å–∫–æ–≥–æ –±–æ—è

### 7.1. –¢–∞–∫—Ç–∏—á–µ—Å–∫–∞—è –∫–∞—Ä—Ç–∞ –∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ

```go
type TacticalCombatSystem struct {
    ActiveCombats    map[string]*NavalCombat `json:"active_combats"`
    CombatSequence   []string                `json:"combat_sequence"`
    TacticalMaps     map[string]*TacticalMap `json:"tactical_maps"`
}

type TacticalMap struct {
    ID              string          `json:"id"`
    GameID          string          `json:"game_id"`
    HexID           string          `json:"hex_id"`
    SeaZones        []SeaZone       `json:"sea_zones"`
    MovementZones   []MovementZone  `json:"movement_zones"`
    Units           []TacticalUnit  `json:"units"`
    Visibility      int             `json:"visibility"`
    CurrentRound    int             `json:"current_round"`
    MaxRounds       int             `json:"max_rounds"`
    Weather         WeatherState    `json:"weather"`
}

type TacticalUnit struct {
    UnitID          string          `json:"unit_id"`
    Position        string          `json:"position"` // Movement Zone ID
    Facing          string          `json:"facing"`   // closing, opening, breaking-off
    CurrentSpeed    int             `json:"current_speed"`
    EvasionEffects  []int           `json:"evasion_effects"`
    DamageTaken     []Damage        `json:"damage_taken"`
    HasFired        bool            `json:"has_fired"`
    TargetAcquired  string          `json:"target_acquired,omitempty"`
    TorpedoesUsed   int             `json:"torpedoes_used"`
    MovementUsed    int             `json:"movement_used"`
}

type CombatManager struct {
    gameState *GameState
    combatServices map[CombatStep]CombatStepHandler
}

func (cm *CombatManager) StartNavalCombat(hexID string, participants []string) (*NavalCombat, error) {
    combat := &NavalCombat{
        ID:           generateCombatID(),
        HexID:        hexID,
        Participants: participants,
        CurrentStep:  StepTorpedoAssignment,
        CurrentRound: 1,
        Status:       "active",
        StartTime:    time.Now(),
    }
    
    // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–∫—Ç–∏—á–µ—Å–∫–æ–π –∫–∞—Ä—Ç—ã
    tacticalMap := cm.createTacticalMap(combat)
    cm.TacticalMaps[combat.ID] = tacticalMap
    
    // –†–∞–∑–º–µ—â–µ–Ω–∏–µ —é–Ω–∏—Ç–æ–≤ –Ω–∞ —Ç–∞–∫—Ç–∏—á–µ—Å–∫–æ–π –∫–∞—Ä—Ç–µ
    cm.placeUnitsOnTacticalMap(combat, tacticalMap)
    
    cm.ActiveCombats[combat.ID] = combat
    cm.CombatSequence = append(cm.CombatSequence, combat.ID)
    
    return combat, nil
}

func (cm *CombatManager) ResolveCombatRound(combatID string) error {
    combat := cm.ActiveCombats[combatID]
    tacticalMap := cm.TacticalMaps[combatID]
    
    // –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —à–∞–≥–æ–≤ –±–æ—è –ø–æ –ø–æ—Ä—è–¥–∫—É
    steps := []CombatStep{
        StepTorpedoAssignment,
        StepFiring,
        StepTorpedoResolution, 
        StepMovement,
        StepAbortAttempt,
        StepReinforcements,
    }
    
    for _, step := range steps {
        combat.CurrentStep = step
        handler := cm.combatServices[step]
        if err := handler.Execute(combat, tacticalMap); err != nil {
            return err
        }
    }
    
    combat.CurrentRound++
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –æ–∫–æ–Ω—á–∞–Ω–∏—è –±–æ—è
    if cm.shouldCombatEnd(combat) {
        cm.endCombat(combat)
    }
    
    return nil
}
```

### 7.2. –°–∏—Å—Ç–µ–º–∞ –æ–≥–Ω—è –∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–π –≤ –±–æ—é

```go
type FiringStepHandler struct {
    gameState *GameState
    combatTables CombatTables
}

func (fsh *FiringStepHandler) Execute(combat *NavalCombat, tacticalMap *TacticalMap) error {
    // –ê—Ç–∞–∫—É—é—â–∏–π —Å—Ç—Ä–µ–ª—è–µ—Ç –ø–µ—Ä–≤—ã–º, –∑–∞—Ç–µ–º –∑–∞—â–∏—â–∞—é—â–∏–π—Å—è
    attackerUnits := fsh.getAttackerUnits(combat)
    defenderUnits := fsh.getDefenderUnits(combat)
    
    // –û–≥–æ–Ω—å –∞—Ç–∞–∫—É—é—â–µ–≥–æ
    for _, unit := range attackerUnits {
        if fsh.canUnitFire(unit, combat) {
            fsh.resolveUnitFire(unit, defenderUnits, combat, tacticalMap)
        }
    }
    
    // –û—Ç–≤–µ—Ç–Ω—ã–π –æ–≥–æ–Ω—å –∑–∞—â–∏—â–∞—é—â–µ–≥–æ—Å—è
    for _, unit := range defenderUnits {
        if fsh.canUnitFire(unit, combat) {
            fsh.resolveUnitFire(unit, attackerUnits, combat, tacticalMap)
        }
    }
    
    return nil
}

func (fsh *FiringStepHandler) resolveUnitFire(firingUnit *TacticalUnit, targetUnits []*TacticalUnit, combat *NavalCombat, tacticalMap *TacticalMap) {
    // –í—ã–±–æ—Ä —Ü–µ–ª–∏
    target := fsh.selectTarget(firingUnit, targetUnits, tacticalMap)
    if target == nil {
        return // –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–µ–ª–µ–π
    }
    
    // –†–∞—Å—á–µ—Ç –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
    range := fsh.calculateRange(firingUnit, target, tacticalMap)
    
    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –≤–æ–æ—Ä—É–∂–µ–Ω–∏—è
    availableWeapons := fsh.getAvailableWeapons(firingUnit, range)
    
    // –†–∞—Å—á–µ—Ç –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤
    modifiers := fsh.calculateFiringModifiers(firingUnit, target, range, combat)
    
    // –ë—Ä–æ—Å–æ–∫ –∫—É–±–æ–≤ –∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ–ø–∞–¥–∞–Ω–∏–π
    hits := fsh.resolveFiring(firingUnit, target, availableWeapons, modifiers, range)
    
    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏–π
    fsh.applyDamage(firingUnit, target, hits, combat)
    
    firingUnit.HasFired = true
}

func (fsh *FiringStepHandler) calculateRange(attacker *TacticalUnit, target *TacticalUnit, tacticalMap *TacticalMap) CombatRange {
    attackerPos := tacticalMap.GetPosition(attacker.Position)
    targetPos := tacticalMap.GetPosition(target.Position)
    
    seaZonesBetween := abs(attackerPos.SeaZone - targetPos.SeaZone)
    
    switch {
    case seaZonesBetween <= 1:
        return RangeShort
    case seaZonesBetween <= 3:
        return RangeMedium
    case seaZonesBetween <= 6:
        return RangeLong
    default:
        return RangeExtreme
    }
}
```

## 8. –°–∏—Å—Ç–µ–º–∞ –æ—á–∫–æ–≤ –ø–æ–±–µ–¥—ã –∏ —É—Å–ª–æ–≤–∏–π –æ–∫–æ–Ω—á–∞–Ω–∏—è –∏–≥—Ä—ã

### 8.1. –†–∞—Å—á–µ—Ç –æ—á–∫–æ–≤ –ø–æ–±–µ–¥—ã

```go
type VictorySystem struct {
    VictoryPoints map[string]int    `json:"victory_points"` // playerID -> VP
    GameEndConditions []GameEndCondition `json:"game_end_conditions"`
}

type VictoryService struct {
    gameState *GameState
    victoryConfig VictoryConfig
}

func (vs *VictoryService) CalculateVictoryPoints() map[string]int {
    vp := make(map[string]int)
    
    // –ë–∞–∑–æ–≤—ã–µ VP –∑–∞ –ø–æ—Ç–æ–ø–ª–µ–Ω–Ω—ã–µ –∫–æ—Ä–∞–±–ª–∏
    vs.addShipVP(vp)
    
    // VP –∑–∞ –∫–æ–Ω–≤–æ–∏ –∏ —Ç–æ—Ä–≥–æ–≤—ã–µ —Å—É–¥–∞
    vs.addConvoyVP(vp)
    
    // –ú–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –∑–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–µ Bismarck
    vs.addBismarckModifiers(vp)
    
    return vp
}

func (vs *VictoryService) addBismarckModifiers(vp map[string]int) {
    bismarck := vs.gameState.GetUnit("bismarck")
    if bismarck == nil {
        return
    }
    
    germanPlayer := bismarck.Owner
    
    switch {
    case bismarck.IsSunk:
        // Bismarck –ø–æ—Ç–æ–ø–ª–µ–Ω - –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è –ø–æ–±–µ–¥–∞ —Å–æ—é–∑–Ω–∏–∫–æ–≤
        vp[germanPlayer] += vs.victoryConfig.BismarckSunkVP
    case bismarck.IsInPort && bismarck.Position == "france_port":
        // Bismarck –≤–æ –§—Ä–∞–Ω—Ü–∏–∏
        vp[germanPlayer] += vs.victoryConfig.BismarckFranceVP
    case bismarck.IsInPort && bismarck.Position == "norway_port":
        // Bismarck –≤ –ù–æ—Ä–≤–µ–≥–∏–∏  
        vp[germanPlayer] += vs.victoryConfig.BismarckNorwayVP
    case bismarck.FuelPoints <= 0:
        // –£ Bismarck –∑–∞–∫–æ–Ω—á–∏–ª–æ—Å—å —Ç–æ–ø–ª–∏–≤–æ
        vp[germanPlayer] += vs.victoryConfig.BismarckNoFuelVP
    case vs.isEndOfGameTrack():
        // –ö–æ–Ω–µ—Ü –∏–≥—Ä–æ–≤–æ–≥–æ —Ç—Ä–µ–∫–∞
        vp[germanPlayer] += vs.victoryConfig.BismarckEndGameVP
    }
}

func (vs *VictoryService) CheckGameEnd() (*GameEndResult, error) {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –æ–∫–æ–Ω—á–∞–Ω–∏—è –∏–≥—Ä—ã
    for _, condition := range vs.GameEndConditions {
        if vs.isConditionMet(condition) {
            result := &GameEndResult{
                Condition: condition,
                VictoryPoints: vs.CalculateVictoryPoints(),
                Winner: vs.determineWinner(),
                VictoryType: vs.determineVictoryType(),
            }
            return result, nil
        }
    }
    
    return nil, nil // –∏–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è
}

func (vs *VictoryService) determineWinner() string {
    vp := vs.CalculateVictoryPoints()
    
    // –ù–µ–º–µ—Ü–∫–∏–π –∏–≥—Ä–æ–∫ –¥–æ–ª–∂–µ–Ω –Ω–∞–±—Ä–∞—Ç—å –º–∏–Ω–∏–º—É–º 1 VP –¥–ª—è –ø–æ–±–µ–¥—ã
    germanPlayer := vs.gameState.GetGermanPlayer()
    if vp[germanPlayer] >= 1 {
        return germanPlayer
    }
    
    // –ò–Ω–∞—á–µ –ø–æ–±–µ–¥–∞ —Å–æ—é–∑–Ω–∏–∫–æ–≤
    return vs.gameState.GetAlliedPlayer()
}
```

## 9. –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏

### 9.1. –ü–æ–ª–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–≥—Ä—ã

```json
{
  "game_config": {
    "general": {
      "max_turns": 30,
      "turns_per_day": 3,
      "starting_date": "1941-05-21",
      "time_per_turn_hours": 4.8,
      "max_real_time_minutes": 180
    },
    
    "victory_conditions": {
      "bismarck_sunk": "allied_operational_victory",
      "bismarck_france": -5,
      "bismarck_norway": -7,
      "bismarck_end_game": -10, 
      "bismarck_no_fuel": -15,
      
      "ship_vp_values": {
        "BB": {"sunk": "hull_boxes", "damaged": "half_hits"},
        "CV": {"sunk": "hull_boxes", "damaged": "half_hits"},
        "BC": {"sunk": "hull_boxes", "damaged": "half_hits"},
        "CA": {"sunk": "hull_boxes", "damaged": "half_hits"},
        "others": {"sunk": 1, "damaged": 0}
      },
      
      "convoy_vp": {
        "single_merchant": 0.5,
        "convoy_min": 1,
        "convoy_max": 2,
        "escort_sunk_multiplier": 1.0
      }
    },
    
    "weather": {
      "change_table": [-2, -1, 0, 0, 1, 1, 2, 2, 3, 3],
      "time_modifiers": {
        "morning": 0,
        "afternoon": 0,
        "night": 3
      },
      "fog_threshold": 5,
      "special_fuel_roll_threshold": 9
    },
    
    "movement": {
      "speed_classes": {
        "very_slow": {
          "movement_interval": 4,
          "fuel_cost": 0,
          "no_movement_markers": [4, 3, 2, 1]
        },
        "slow": {
          "movement_interval": 2, 
          "fuel_cost": 0,
          "no_movement_markers": [2, 1]
        },
        "medium": {
          "movement_interval": 1,
          "fuel_cost": {
            "consecutive": 1,
            "alternating": 0
          }
        },
        "fast": {
          "movement_interval": 1,
          "fuel_cost": {
            "zero_or_one_hex": 0,
            "two_hexes_after_zero_or_one": 1,
            "two_hexes_after_two": 2
          },
          "damaged_movement_limit": 1
        }
      },
      
      "restrictions": {
        "german_dd_boundary": ["Q29", "R28", "S27", "T26"],
        "tanker_convoy_hexes": true,
        "kaiser_wilhelm_canal": ["O32", "O33"]
      }
    },
    
    "combat": {
      "max_rounds": 10,
      "reinforcement_start_round": 3,
      "ranges": {
        "short": 1,
        "medium": 2, 
        "long": 4,
        "extreme": 7
      },
      
      "tables": {
        "naval_combat": {
          "ranges": ["extreme", "long", "medium", "short"],
          "dice_multipliers": [0.33, 0.5, 1.0, 1.5],
          "results_table": {...}
        },
        "torpedo_attack": {...},
        "air_attack": {...}
      },
      
      "modifiers": {
        "target_acquired": -1,
        "radar_i": -1,
        "radar_ii": -2,
        "closing_or_breaking_off": +1,
        "vs_closing_or_breaking_off": +1,
        "fire_control_damage": +1,
        "visibility_4_6": +1,
        "visibility_7_9": +3
      }
    },
    
    "search": {
      "base_factors": {
        "ship": 1,
        "task_force": 1,
        "patrol": 3,
        "flight_path": 2
      },
      "max_additional_markers": 2,
      "cost_per_additional_marker": "current_visibility_level"
    },
    
    "repair": {
      "at_sea_table": {
        "0": "+5_evasion_or_rudder_repaired",
        "1": "+3_evasion", 
        "2": "+2_evasion",
        "3-9": "failure"
      },
      "modifiers": {
        "weather_4_6": "+1",
        "weather_7_9": "+2"
      }
    },
    
    "optional_rules": {
      "hypothetical_units": {
        "tirpitz": {"vp_cost": -9, "setup_hex": "O33", "reveal_on": "0-8"},
        "scharnhorst": {"vp_cost": -7, "setup_hex": "U26", "reveal_on": "0-7"},
        "gneisenau": {"vp_cost": -8, "setup_hex": "U26", "reveal_on": "0-5"}
      },
      "crew_exhaustion": true
    }
  }
}
```

## 10. –°–∏—Å—Ç–µ–º–∞ —Ä–µ–ø–ª–µ–µ–≤ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏

### 10.1. –ü–æ–ª–Ω–∞—è –∑–∞–ø–∏—Å—å –∏–≥—Ä—ã –¥–ª—è —Ä–µ–ø–ª–µ–µ–≤

```go
type GameRecorder struct {
    gameID      string
    snapshots   []*GameSnapshot
    actions     []*ReplayAction
    events      []*GameEvent
    metadata    *ReplayMetadata
}

type GameSnapshot struct {
    ID           string          `json:"id"`
    GameID       string          `json:"game_id"`
    Turn         int             `json:"turn"`
    Phase        GamePhase       `json:"phase"`
    Timestamp    time.Time       `json:"timestamp"`
    Sequence     int             `json:"sequence"`
    FullState    *FullGameState  `json:"full_state"`
    PlayerViews  map[string]*PlayerView `json:"player_views"`
    Action       *ReplayAction   `json:"action,omitempty"`
    KeyEvents    []*GameEvent    `json:"key_events,omitempty"`
}

type FullGameState struct {
    // –ü–æ–ª–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã (–±–µ–∑ —Ç—É–º–∞–Ω–∞ –≤–æ–π–Ω—ã)
    AllUnits        map[string]*NavalUnit    `json:"all_units"`
    AllAirUnits     map[string]*AirUnit      `json:"all_air_units"`
    AllTaskForces   map[string]*TaskForce    `json:"all_task_forces"`
    AllMarkers      map[string][]*GameMarker `json:"all_markers"`
    Weather         *WeatherState            `json:"weather"`
    ActiveConvoys   map[string]*ConvoyInstance `json:"active_convoys"`
    VictoryPoints   map[string]int           `json:"victory_points"`
    TurnTrack       *TurnTrackState          `json:"turn_track"`
    PhaseTrack      *PhaseTrackState         `json:"phase_track"`
    
    // –ú–µ—Ç–∞-–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
    CurrentPlayer   string                   `json:"current_player"`
    GameSettings    *GameSettings            `json:"game_settings"`
    TimeElapsed     int                      `json:"time_elapsed"` // –≤ –º–∏–Ω—É—Ç–∞—Ö
}

type ReplayAction struct {
    ID          string          `json:"id"`
    GameID      string          `json:"game_id"`
    PlayerID    string          `json:"player_id"`
    ActionType  ActionType      `json:"action_type"`
    Data        interface{}     `json:"data"`
    Timestamp   time.Time       `json:"timestamp"`
    Phase       GamePhase       `json:"phase"`
    Turn        int             `json:"turn"`
    Sequence    int             `json:"sequence"`
    Validated   bool            `json:"validated"`
    ServerTime  time.Time       `json:"server_time"`
    
    // –î–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ —Ä–µ–ø–ª–µ–µ
    Description string          `json:"description"`
    UIState     *UIStateSnapshot `json:"ui_state,omitempty"`
}

func (gr *GameRecorder) TakeSnapshot(action *ReplayAction) error {
    snapshot := &GameSnapshot{
        ID:        generateSnapshotID(),
        GameID:    gr.gameID,
        Turn:      gr.gameState.CurrentTurn,
        Phase:     gr.gameState.CurrentPhase,
        Timestamp: time.Now(),
        Sequence:  len(gr.snapshots),
        FullState: gr.captureFullState(),
        Action:    action,
    }
    
    // –ó–∞–ø–∏—Å—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–π –∏–≥—Ä–æ–∫–æ–≤ (—á—Ç–æ –≤–∏–¥–µ–ª –∫–∞–∂–¥—ã–π –∏–≥—Ä–æ–∫)
    for _, playerID := range gr.gameState.PlayerIDs {
        snapshot.PlayerViews[playerID] = gr.capturePlayerView(playerID)
    }
    
    gr.snapshots = append(gr.snapshots, snapshot)
    return nil
}

func (gr *GameRecorder) captureFullState() *FullGameState {
    return &FullGameState{
        AllUnits:        gr.deepCopyUnits(gr.gameState.AllUnits),
        AllAirUnits:     gr.deepCopyUnits(gr.gameState.AllAirUnits),
        AllTaskForces:   gr.deepCopyTaskForces(gr.gameState.TaskForces),
        AllMarkers:      gr.deepCopyMarkers(gr.gameState.Markers),
        Weather:         gr.gameState.Weather.Clone(),
        ActiveConvoys:   gr.deepCopyConvoys(gr.gameState.ActiveConvoys),
        VictoryPoints:   copyMap(gr.gameState.VictoryPoints),
        TurnTrack:       gr.gameState.TurnTrack.Clone(),
        PhaseTrack:      gr.gameState.PhaseTrack.Clone(),
        CurrentPlayer:   gr.gameState.CurrentPlayer,
        GameSettings:    gr.gameState.Settings.Clone(),
        TimeElapsed:     gr.gameState.TimeElapsed,
    }
}
```

### 10.2. API –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ä–µ–ø–ª–µ—è–º–∏

```go
type ReplayAPI struct {
    gameService *GameService
    replayStore ReplayStore
}

func (ra *ReplayAPI) GetGameReplay(gameID string) (*GameReplay, error) {
    replay, err := ra.replayStore.GetReplay(gameID)
    if err != nil {
        return nil, err
    }
    
    return replay, nil
}

func (ra *ReplayAPI) GetReplaySnapshot(gameID string, turn int, phase GamePhase, sequence int) (*GameSnapshot, error) {
    replay, err := ra.replayStore.GetReplay(gameID)
    if err != nil {
        return nil, err
    }
    
    for _, snapshot := range replay.Snapshots {
        if snapshot.Turn == turn && snapshot.Phase == phase && snapshot.Sequence == sequence {
            return snapshot, nil
        }
    }
    
    return nil, errors.New("snapshot not found")
}

func (ra *ReplayAPI) GetReplayTimeline(gameID string) (*ReplayTimeline, error) {
    replay, err := ra.replayStore.GetReplay(gameID)
    if err != nil {
        return nil, err
    }
    
    timeline := &ReplayTimeline{
        GameID: gameID,
        Events: []*TimelineEvent{},
    }
    
    for _, snapshot := range replay.Snapshots {
        event := &TimelineEvent{
            Turn:      snapshot.Turn,
            Phase:     snapshot.Phase,
            Timestamp: snapshot.Timestamp,
            Type:      "snapshot",
            Data:      snapshot,
        }
        timeline.Events = append(timeline.Events, event)
    }
    
    for _, action := range replay.Actions {
        event := &TimelineEvent{
            Turn:      action.Turn,
            Phase:     action.Phase,
            Timestamp: action.Timestamp,
            Type:      "action",
            Data:      action,
        }
        timeline.Events = append(timeline.Events, event)
    }
    
    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
    sort.Slice(timeline.Events, func(i, j int) bool {
        return timeline.Events[i].Timestamp.Before(timeline.Events[j].Timestamp)
    })
    
    return timeline, nil
}
```

–≠—Ç–æ –ø–æ–ª–Ω–æ–µ –¢–ó —Ç–µ–ø–µ—Ä—å –≤–∫–ª—é—á–∞–µ—Ç –≤—Å–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å–∏—Å—Ç–µ–º—ã –∏–≥—Ä—ã, –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö, –ø–æ–ª–Ω—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –∏ –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–ª–Ω–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –≤–µ–±-–≤–µ—Ä—Å–∏–∏ –∏–≥—Ä—ã "–ü–æ–≥–æ–Ω—è –∑–∞ –ë–∏—Å–º–∞—Ä–∫–æ–º".